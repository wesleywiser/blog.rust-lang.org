<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2019-10-11T16:30:30Z</updated>

    
    <entry>
        <title>Improving async-await's &quot;Future is not Send&quot; diagnostic</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/11/AsyncAwait-Not-Send-Error-Improvements.html" type="text/html" title="Improving async-await's &quot;Future is not Send&quot; diagnostic" />
        <published>2019-10-11T00:00:00Z</published>
        <updated>2019-10-11T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/11/AsyncAwait-Not-Send-Error-Improvements.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/11/AsyncAwait-Not-Send-Error-Improvements.html">&lt;p&gt;Async-await is due to hit stable in the 1.39 release (only a month away!), and as announced in the
&lt;a href=&quot;https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html&quot;&gt;&amp;quot;Async Foundations Update: Time for polish!&amp;quot;&lt;/a&gt; post last month, the Async
Foundations WG has shifted its focus to polish. This post will highlight one aspect of that
focus, diagnostic improvements, and in particular, the improvements that the working group has
been making to the once-unhelpful &amp;quot;future is not send&amp;quot; diagnostic.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#why-doesnt-my-future-implement-send?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;why-doesnt-my-future-implement-send?&quot;&gt;&lt;/a&gt;Why doesn't my future implement &lt;code&gt;Send&lt;/code&gt;?&lt;/h1&gt;
&lt;p&gt;One of the major places where async-await should be a pleasure to use is in multithreaded contexts,
where having a future that can be sent to other threads is desirable. This might look something
like the following (for brevity, there aren't any threads here, just a requirement that the
future implement &lt;code&gt;std::marker::Send&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::sync::{Mutex, MutexGuard};

fn is_send&amp;lt;T: Send&amp;gt;(t: T) { }

async fn foo() {
    bar(&amp;amp;Mutex::new(22)).await
}

async fn bar(x: &amp;amp;Mutex&amp;lt;u32&amp;gt;) {
    let g = x.lock().unwrap();
    baz().await
}

async fn baz() { }

fn main() {
    is_send(foo());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we try to compile this, we'll get an unwieldly and hard-to-follow diagnostic:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0277]: `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;` cannot be sent between threads safely
  --&amp;gt; src/main.rs:23:5
   |
23 |     is_send(foo());
   |     ^^^^^^^ `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;` cannot be sent between threads safely
   |
   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;`
   = note: required because it appears within the type `for&amp;lt;'r, 's&amp;gt; {&amp;amp;'r std::sync::Mutex&amp;lt;u32&amp;gt;, std::sync::MutexGuard&amp;lt;'s, u32&amp;gt;, impl std::future::Future, ()}`
   = note: required because it appears within the type `[static generator@src/main.rs:13:30: 16:2 x:&amp;amp;std::sync::Mutex&amp;lt;u32&amp;gt; for&amp;lt;'r, 's&amp;gt; {&amp;amp;'r std::sync::Mutex&amp;lt;u32&amp;gt;, std::sync::MutexGuard&amp;lt;'s, u32&amp;gt;, impl std::future::Future, ()}]`
   = note: required because it appears within the type `std::future::GenFuture&amp;lt;[static generator@src/main.rs:13:30: 16:2 x:&amp;amp;std::sync::Mutex&amp;lt;u32&amp;gt; for&amp;lt;'r, 's&amp;gt; {&amp;amp;'r std::sync::Mutex&amp;lt;u32&amp;gt;, std::sync::MutexGuard&amp;lt;'s, u32&amp;gt;, impl std::future::Future, ()}]&amp;gt;`
   = note: required because it appears within the type `impl std::future::Future`
   = note: required because it appears within the type `impl std::future::Future`
   = note: required because it appears within the type `for&amp;lt;'r&amp;gt; {impl std::future::Future, ()}`
   = note: required because it appears within the type `[static generator@src/main.rs:9:16: 11:2 for&amp;lt;'r&amp;gt; {impl std::future::Future, ()}]`
   = note: required because it appears within the type `std::future::GenFuture&amp;lt;[static generator@src/main.rs:9:16: 11:2 for&amp;lt;'r&amp;gt; {impl std::future::Future, ()}]&amp;gt;`
   = note: required because it appears within the type `impl std::future::Future`
   = note: required because it appears within the type `impl std::future::Future`
note: required by `is_send`
  --&amp;gt; src/main.rs:5:1
   |
5  | fn is_send&amp;lt;T: Send&amp;gt;(t: T) {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's.. not great. Let's break down what's happening and understand what this error is trying to
tell us.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    is_send(foo());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;code&gt;main&lt;/code&gt;, we are calling &lt;code&gt;foo&lt;/code&gt; and passing the return value to &lt;code&gt;is_send&lt;/code&gt;. &lt;code&gt;foo&lt;/code&gt; is an &lt;code&gt;async fn&lt;/code&gt;,
so it doesn't return &lt;code&gt;()&lt;/code&gt; (what you might expect for a function with no return type specified).
Instead, it returns &lt;code&gt;impl std::future::Future&amp;lt;Output = ()&amp;gt;&lt;/code&gt;, some unnamed type that implements
&lt;code&gt;std::future::Future&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn foo() {
    bar(&amp;amp;Mutex::new(22)).await
}

// becomes...

fn foo() -&amp;gt; impl std::future::Future&amp;lt;Output = ()&amp;gt; {
    async move {
        bar(&amp;amp;Mutex::new(22)).await
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to learn more about the transformations that happen with async-await, consider
reading the &lt;a href=&quot;https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html&quot;&gt;&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;.await&lt;/code&gt; primer chapter of the async book&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn is_send&amp;lt;T: Send&amp;gt;(t: T) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It looks like the error we're getting is because the future returned by &lt;code&gt;foo&lt;/code&gt; doesn't satisfy
the &lt;code&gt;T: Send&lt;/code&gt; bound of &lt;code&gt;is_send&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#how-are-async-functions-implemented&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;how-are-async-functions-implemented&quot;&gt;&lt;/a&gt;How are async functions implemented?&lt;/h2&gt;
&lt;p&gt;To explain why our future doesn't implement &lt;code&gt;Send&lt;/code&gt;, we first need to understand a little bit more
about what async-await is doing under the hood. rustc implements &lt;code&gt;async fn&lt;/code&gt;s using generators,
an unstable language feature for resumable functions like the co-routines you might be familiar
with from other languages. Generators are laid out like enums with variants containing all of the
variables that are used across await points (which desugar to generator yields):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn bar(x: &amp;amp;Mutex&amp;lt;u32&amp;gt;) {
    let g = x.lock().unwrap();
    baz().await // &amp;lt;- await point (suspend #0), `g` and `x` are in use before await point
} // &amp;lt;- `g` and `x` dropped here, after await point
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;enum BarGenerator {
    Unresumed { x: &amp;amp;Mutex&amp;lt;u32&amp;gt;, g: MutexGuard&amp;lt;'_, u32&amp;gt;, },
    Suspend0 { x: &amp;amp;Mutex&amp;lt;u32&amp;gt;, g: MutexGuard&amp;lt;'_, u32&amp;gt;, }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to learn more about the &lt;code&gt;async fn&lt;/code&gt; implementation details, then Tyler Mandry has
written &lt;a href=&quot;https://tmandry.gitlab.io/blog/posts/optimizing-await-1/&quot;&gt;an excellent blog post&lt;/a&gt; diving into their work here in more depth which is
definitely worth a read.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#so-why-doesn't-my-future-implement-send?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;so-why-doesn't-my-future-implement-send?&quot;&gt;&lt;/a&gt;So, why doesn't my future implement &lt;code&gt;Send&lt;/code&gt;?&lt;/h2&gt;
&lt;p&gt;We now know that an &lt;code&gt;async fn&lt;/code&gt; is represented like an enum behind-the-scenes. In synchronous Rust,
you'll be used to your types automatically implementing &lt;code&gt;Send&lt;/code&gt; when the
&lt;a href=&quot;https://doc.rust-lang.org/std/marker/trait.Send.html&quot;&gt;compiler determines it's appropriate&lt;/a&gt; - typically when all of the fields of your type
also implement &lt;code&gt;Send&lt;/code&gt;. It follows that the enum-like that represents our &lt;code&gt;async fn&lt;/code&gt; would
implement &lt;code&gt;Send&lt;/code&gt; if all of the types in it do.&lt;/p&gt;
&lt;p&gt;In other words, a future is safe to send across threads if all of the types that are held across
&lt;code&gt;.await&lt;/code&gt; points implement &lt;code&gt;Send&lt;/code&gt;. This behaviour is useful because it lets us write generic code
that interoperates smoothly with async-await, but without diagnostic support we get confusing error
messages.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#well-which-type-is-the-problem-in-the-example?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;well-which-type-is-the-problem-in-the-example?&quot;&gt;&lt;/a&gt;Well, which type is the problem in the example?&lt;/h2&gt;
&lt;p&gt;Returning to our example, the future must be holding a type across an &lt;code&gt;.await&lt;/code&gt; point that doesn't
implement &lt;code&gt;Send&lt;/code&gt;, but where? This is the primary question that the diagnostic improvement aims to
help answer. Let's start by looking at &lt;code&gt;foo&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn foo() {
    bar(&amp;amp;Mutex::new(22)).await
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;foo&lt;/code&gt; invokes &lt;code&gt;bar&lt;/code&gt;, passing a reference to a &lt;code&gt;std::sync::Mutex&lt;/code&gt; and getting a future back, before
&lt;code&gt;await&lt;/code&gt;ing it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;async fn bar(x: &amp;amp;Mutex&amp;lt;u32&amp;gt;) {
    let g: MutexGuard&amp;lt;u32&amp;gt; = x.lock().unwrap();
    baz().await
} // &amp;lt;- `g` is dropped here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bar&lt;/code&gt; unlocks the mutex before &lt;code&gt;await&lt;/code&gt;ing &lt;code&gt;baz&lt;/code&gt;. &lt;code&gt;std::sync::MutexGuard&amp;lt;u32&amp;gt;&lt;/code&gt; does not implement
&lt;code&gt;Send&lt;/code&gt; and lives across the &lt;code&gt;baz().await&lt;/code&gt; point (because &lt;code&gt;g&lt;/code&gt; is dropped at the end of the scope)
which causes the entire future not to implement &lt;code&gt;Send&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;That wasn't obvious from the error: we had to know that futures might implement &lt;code&gt;Send&lt;/code&gt; depending
on the types they capture &lt;em&gt;and&lt;/em&gt; find the type which lives across an await point ourselves.&lt;/p&gt;
&lt;p&gt;Fortunately, the Async Foundations WG has been working to improve this error, and
&lt;a href=&quot;https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=7e80a8bc151df8817e0983e55bf2667a&quot;&gt;in nightly&lt;/a&gt;, we see the following diagnostic instead:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0277]: `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;` cannot be sent between threads safely
  --&amp;gt; src/main.rs:23:5
   |
5  | fn is_send&amp;lt;T: Send&amp;gt;(t: T) {
   |    -------    ---- required by this bound in `is_send`
...
23 |     is_send(foo());
   |     ^^^^^^^ `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;` cannot be sent between threads safely
   |
   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;`
note: future does not implement `std::marker::Send` as this value is used across an await
  --&amp;gt; src/main.rs:15:3
   |
14 |   let g = x.lock().unwrap();
   |       - has type `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;`
15 |   baz().await;
   |   ^^^^^^^^^^^ await occurs here, with `g` maybe used later
16 | }
   | - `g` is later dropped here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Much better!&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#how-does-it-work&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;how-does-it-work&quot;&gt;&lt;/a&gt;How does it work?&lt;/h1&gt;
&lt;p&gt;When rustc's trait system determines that a trait wasn't implemented, in this case
&lt;code&gt;std::marker::Send&lt;/code&gt;, it emits this error. The trait system produces a chain of &amp;quot;obligations&amp;quot;.
Obligations are types which denote where a bound (e.g &lt;code&gt;T: Send&lt;/code&gt; in &lt;code&gt;is_send&lt;/code&gt;) originated,
or where a bound was propagated.&lt;/p&gt;
&lt;p&gt;To improve this diagnostic, the chain of obligations is now treated like a stack frame, where
each &amp;quot;frame&amp;quot; of obligations represents each function's contribution to the error. Let's make
that more concrete with a very rough approximation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;Obligation {
    kind: DerivedObligation(/* generator that captured `g` */),
    source: /* `Span` type pointing at `bar`'s location in user code */,
    parent: Some(Obligation {
        kind: DerivedObligation(/* generator calling `bar` */),
        source: /* `Span` type pointing at `foo`'s location in user code */,
        parent: Some(Obligation {
            kind: ItemObligation(/* type representing `std::marker::Send` */),
            source: /* `Span` type pointing at `is_send`'s location in user code */,
            cause: None,
        }),
    }),
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The compiler matches against the chain expecting an &lt;code&gt;ItemObligation&lt;/code&gt; and some &lt;code&gt;DerivedObligation&lt;/code&gt;s
containing generators, which identifies the error we want to improve. Using information from these
obligations, rustc can construct the specialized error shown above - if you'd like to see what the
actual implementation looks like, check out PR &lt;a href=&quot;https://github.com/rust-lang/rust/pulls/64895&quot;&gt;#64895&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you're interested in improving diagnostics like this, or even just fixing bugs, consider
contributing to the compiler! There are many working groups to join and resources to help you get
started (like the &lt;a href=&quot;https://rust-lang.github.io/rustc-guide&quot;&gt;rustc guide&lt;/a&gt; or the &lt;a href=&quot;https://rust-lang.github.io/compiler-team&quot;&gt;compiler team documentation&lt;/a&gt;).&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#whats-next?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-next?&quot;&gt;&lt;/a&gt;What's next?&lt;/h1&gt;
&lt;p&gt;More improvements to this diagnostic are planned and being worked on, so that it is applicable in
more cases, and has specialized messages for &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt;, like below:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0277]: future cannot be sent between threads safely
  --&amp;gt; src/main.rs:23:5
   |
5  | fn is_send&amp;lt;T: Send&amp;gt;(t: T) {
   |    -------    ---- required by this bound in `is_send`
...
23 |     is_send(foo());
   |     ^^^^^^^ future returned by `foo` is not `Send`
   |
   = help:  future is not `Send` as this value is used across an await
note: future does not implement `std::marker::Send` as this value is used across an await
  --&amp;gt; src/main.rs:15:3
   |
14 |   let g = x.lock().unwrap();
   |       - has type `std::sync::MutexGuard&amp;lt;'_, u32&amp;gt;`
15 |   baz().await;
   |   ^^^^^^^^^^^ await occurs here, with `g` maybe used later
16 | }
   | - `g` is later dropped here
&lt;/code&gt;&lt;/pre&gt;
</content>

        <author>
            <name>David Wood</name>
        </author>
    </entry>
    
    <entry>
        <title>Async Foundations Update: Time for polish!</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html" type="text/html" title="Async Foundations Update: Time for polish!" />
        <published>2019-10-07T00:00:00Z</published>
        <updated>2019-10-07T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html">&lt;p&gt;As you've perhaps heard, recently the async-await feature &lt;a href=&quot;/2019/09/30/Async-await-hits-beta.html&quot;&gt;landed on
the Rust beta branch&lt;/a&gt;. This marks a big turning point in the
usability story for Async Rust. But there's still a lot of work to do.
As we mentioned in the main post, the focus for the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/&quot;&gt;Async Foundations
WG&lt;/a&gt; in the immediate term is going to be &lt;strong&gt;polish&lt;/strong&gt;, &lt;strong&gt;polish&lt;/strong&gt;
and (ahem) &lt;strong&gt;more polish&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In particular, we want to take aim at a backlog of strange
diagnostics, suboptimal performance, and the occasional inexplicable
type-check failure. This is a shift: whereas before, we could have
laser focus on things that truly blocked stabilization, we've now got
a large set of bugs, often without a clear prioritization between
them. This requires us to mix up how the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/&quot;&gt;Async Foundations WG&lt;/a&gt; is
operating.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#announcing-focus-issues&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;announcing-focus-issues&quot;&gt;&lt;/a&gt;Announcing: focus issues&lt;/h3&gt;
&lt;p&gt;So how do you deal with a large pile of issues, all of which are
important but none of which are vital? One at a time, of course.&lt;/p&gt;
&lt;p&gt;The way we've chosen to organize this is something we call &lt;strong&gt;&lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/#how-to-get-involved&quot;&gt;focus
issues&lt;/a&gt;&lt;/strong&gt;. We're trying to keep a small number of issues tagged as
focus issues at any given time. As we close them, we'll pick new ones
to replace them. The number of these issues depends on mentoring
bandwidth and on how many people are hacking -- as a rule of thumb,
they should mostly all be assigned and actively progressing at any
given time.&lt;/p&gt;
&lt;p&gt;We also have a secondary set of issues called &lt;strong&gt;on deck issues&lt;/strong&gt;.
These are the candidates to become focus issues as focus issues are
completed. If you'd like us to consider fixing something sooner rather
than later, you can &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/#nominating-issues&quot;&gt;add the &amp;quot;on deck&amp;quot; label yourself&lt;/a&gt;, along
with a bit of context explaining why you think this issue is more
important than the rest.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#how-you-can-help&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;how-you-can-help&quot;&gt;&lt;/a&gt;How you can help&lt;/h3&gt;
&lt;p&gt;You can help in two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Fix bugs!&lt;/strong&gt; If you'd like to take a shot at fixing a bug, try to
come to the &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/#triage-meeting&quot;&gt;triage meeting&lt;/a&gt; or just show up in
&lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations&quot;&gt;&lt;code&gt;#wg-async-foundations&lt;/code&gt; on Zulip&lt;/a&gt;. Maybe we can find something
for you.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nominate bugs!&lt;/strong&gt; If you've got a bug that is really
annoying you, feel free to &amp;quot;nominate it&amp;quot; by &lt;a href=&quot;https://rust-lang.github.io/compiler-team/working-groups/async-await/#nominating-issues&quot;&gt;following the
instructions here&lt;/a&gt;. This will help us to fix the things that
are bothering people the most.&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Keeping Rust projects secure with cargo-audit 0.9: dependency trees, core advisories, unmaintained crates</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/10/03/Keeping-secure-with-cargo-audit-0.9.html" type="text/html" title="Keeping Rust projects secure with cargo-audit 0.9: dependency trees, core advisories, unmaintained crates" />
        <published>2019-10-03T00:00:00Z</published>
        <updated>2019-10-03T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/10/03/Keeping-secure-with-cargo-audit-0.9.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/10/03/Keeping-secure-with-cargo-audit-0.9.html">&lt;p&gt;&lt;a href=&quot;https://github.com/rustsec/cargo-audit&quot;&gt;cargo-audit&lt;/a&gt; is a command-line utility which inspects &lt;code&gt;Cargo.lock&lt;/code&gt; files and compares them against the &lt;a href=&quot;https://rustsec.org&quot;&gt;RustSec Advisory Database&lt;/a&gt;, a community database of security vulnerabilities maintained by the &lt;a href=&quot;https://github.com/rust-secure-code/wg&quot;&gt;Rust Secure Code Working Group&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can install &lt;code&gt;cargo-audit&lt;/code&gt; and run it against your project with the following commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo install cargo-audit
$ cargo audit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 0.9 release of &lt;code&gt;cargo-audit&lt;/code&gt; includes a number of new features we hope make it more useful, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI improvements for understanding how vulnerabilities apply to your project&lt;/li&gt;
&lt;li&gt;Warnings for unmaintained crate dependencies (with an option to hard fail)&lt;/li&gt;
&lt;li&gt;Tracking of vulnerabilities in the Rust language itself&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#ui-improvements-dependency-trees&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;ui-improvements-dependency-trees&quot;&gt;&lt;/a&gt;UI improvements: dependency trees&lt;/h2&gt;
&lt;p&gt;Previously, when &lt;code&gt;cargo-audit&lt;/code&gt; found a vulnerability in a project, it would display advisory information without any context as to how a particular vulnerable dependency is included in your project, making it difficult to determine what action needs to be taken to resolve the vulnerability.&lt;/p&gt;
&lt;p&gt;The latest release prints an inverse dependency tree (ala the excellent &lt;a href=&quot;https://github.com/sfackler/cargo-tree&quot;&gt;cargo-tree&lt;/a&gt; crate) for each advisory showing how a vulnerable dependency is included in your project:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RustSec/cargo-audit/a840f7b/screenshot.png&quot; alt=&quot;cargo audit with dependency tree&quot; /&gt;&lt;/p&gt;
&lt;p&gt;In future versions of &lt;code&gt;cargo-audit&lt;/code&gt; we &lt;a href=&quot;https://github.com/RustSec/cargo-audit/issues/23&quot;&gt;hope to add a &lt;code&gt;cargo audit fix&lt;/code&gt; command&lt;/a&gt; ala &lt;code&gt;npm audit fix&lt;/code&gt; which can either automatically update the necessary dependencies or provide instructions on how to do so. If that feature interests you and you'd like to contribute, &lt;a href=&quot;https://github.com/RustSec/cargo-audit/issues/23&quot;&gt;we're looking for help&lt;/a&gt;!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#new-feature-unmaintained-crate-warnings&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;new-feature-unmaintained-crate-warnings&quot;&gt;&lt;/a&gt;New feature: unmaintained crate warnings&lt;/h2&gt;
&lt;p&gt;This release added the notion of &lt;a href=&quot;https://github.com/RustSec/rustsec-crate/pull/75&quot;&gt;informational advisories&lt;/a&gt; - advisories which don't directly represent a security vulnerability, but may contain potentially security-relevant information. The primary intended use for this feature is &lt;a href=&quot;https://github.com/RustSec/advisory-db/issues/173&quot;&gt;providing warnings for unmaintained crates&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A recent study, &lt;a href=&quot;https://www.usenix.org/system/files/sec19-zimmermann.pdf&quot;&gt;Small World with High Risks: A Study of Security Threats in the npm Ecosystem&lt;/a&gt;, showed that unmaintained npm packages pose a high risk to that ecosystem:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Our results provide evidence that npm suffers from single points of failure and that unmaintained packages threaten large code bases&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Rust is in a similar boat with some high profile crates, &lt;a href=&quot;https://github.com/Stebalien/term/issues/93&quot;&gt;such as the &lt;code&gt;term&lt;/code&gt; crate&lt;/a&gt; (downloaded 8,000 times a day), are unmaintained. By &lt;a href=&quot;https://github.com/RustSec/advisory-db/issues/173&quot;&gt;tracking information about unmaintained crates in the RustSec Advisory Database&lt;/a&gt;, we hope to improve visibility on these crates, either by helping people discover &amp;quot;successor&amp;quot; crates they should switch to, or putting potential volunteer maintainers in touch with authors interested in handing crates off. When those handoffs happen, we can mark unmaintained crate advisories as obsolete (while still giving interested security researchers a list of crates to keep an eye on for potential &lt;a href=&quot;https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident&quot;&gt;software supply chain attacks&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;If you have an unmaintained crate you'd like us to create an advisory for, or know of a third party unmaintained crate and would like to provide information about potential alternatives, please &lt;a href=&quot;https://github.com/RustSec/advisory-db/issues/173&quot;&gt;leave a comment in the RustSec/advisory-db#173 GitHub issue&lt;/a&gt; and we can file an advisory for it.&lt;/p&gt;
&lt;p&gt;For now, unmaintained crates are surfaced as warnings, with some brief information available about each one and a link to click to read more. If you'd like for unmaintained crate advisories to be considered errors (so &lt;code&gt;cargo-audit&lt;/code&gt; exits with a non-zero status for e.g. CI purposes), run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo audit -D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or if you prefer to be more explicit:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo audit --deny-warnings
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#tracking-rust-language-vulnerabilities&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;tracking-rust-language-vulnerabilities&quot;&gt;&lt;/a&gt;Tracking Rust language vulnerabilities&lt;/h2&gt;
&lt;p&gt;Previously the &lt;a href=&quot;https://rustsec.org&quot;&gt;RustSec Advisory Database&lt;/a&gt; only tracked information about vulnerable crates published through &lt;a href=&quot;https://crates.io&quot;&gt;crates.io&lt;/a&gt;. Starting with this release, however, we are also indexing advisories for vulnerabilities in the Rust language's core ecosystem components, including &lt;code&gt;std&lt;/code&gt;, &lt;code&gt;cargo&lt;/code&gt;, and &lt;code&gt;rustdoc&lt;/code&gt;. We've now indexed the following vulnerabilities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://rustsec.org/advisories/CVE-2018-1000622.html&quot;&gt;CVE-2018-1000622: rustdoc: Uncontrolled search path element vulnerability in rustdoc plugins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustsec.org/advisories/CVE-2018-1000657.html&quot;&gt;CVE-2018-1000657: std: Buffer overflow vulnenrability in &lt;code&gt;VecDeque::reserve()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustsec.org/advisories/CVE-2018-1000810.html&quot;&gt;CVE-2018-1000810: std: Buffer overflow vulnerability in &lt;code&gt;str::repeat()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustsec.org/advisories/CVE-2019-12083.html&quot;&gt;CVE-2019-12083: std: Memory safety vulnerabilities arising from &lt;code&gt;Error::type_id&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustsec.org/advisories/CVE-2019-16760.html&quot;&gt;CVE-2019-16760: cargo: Cargo prior to Rust 1.26.0 may download the wrong dependency&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We are &lt;a href=&quot;https://github.com/RustSec/cargo-audit/issues/140&quot;&gt;interested in potentially surfacing information about these advisories via cargo-audit&lt;/a&gt;, e.g. optionally detecting if the currently active Rust toolchain is vulnerable. If that interests you, we're also looking for help on this issue!&lt;/p&gt;
&lt;p&gt;Thanks for reading, and we hope you enjoy &lt;code&gt;cargo-audit&lt;/code&gt; 0.9!&lt;/p&gt;
</content>

        <author>
            <name>Tony Arcieri</name>
        </author>
    </entry>
    
    <entry>
        <title>Welcome to the Inside Rust blog!</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2019/09/25/Welcome.html" type="text/html" title="Welcome to the Inside Rust blog!" />
        <published>2019-09-25T00:00:00Z</published>
        <updated>2019-09-25T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/inside-rust/2019/09/25/Welcome.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2019/09/25/Welcome.html">&lt;p&gt;Welcome to the inaugural post of the &lt;strong&gt;Inside Rust&lt;/strong&gt; blog! This is a
new blog where the various Rust teams and working groups can post
updates about new developments. It's a great place to watch if you're
interested in following along with Rust development -- and a
particularly great place to watch if you're interested in contributing
to Rust. Expect to see updates on new projects, calls for help, design
notes, and other similar items. Thanks for reading!&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
</feed>
