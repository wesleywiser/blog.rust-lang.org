<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Team.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2019-04-23T22:02:45Z</updated>

    
    <entry>
        <title>Rust's 2019 roadmap</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/23/roadmap.html" type="text/html" title="Rust's 2019 roadmap" />
        <published>2019-04-23T00:00:00Z</published>
        <updated>2019-04-23T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/23/roadmap.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/23/roadmap.html">&lt;p&gt;Each year the Rust community &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1728&quot;&gt;comes together&lt;/a&gt; to set out a
roadmap. This year, in addition to the &lt;a href=&quot;https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html&quot;&gt;survey&lt;/a&gt;, we put out a &lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html&quot;&gt;call for blog
posts&lt;/a&gt; in December, which resulted in &lt;a href=&quot;https://readrust.net/rust-2019/&quot;&gt;73 blog posts&lt;/a&gt;
written over the span of a few weeks. The end result is the recently-merged
&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md&quot;&gt;2019 roadmap RFC&lt;/a&gt;. To get all of the details, please give it a read,
but this post lays out some of the highlights.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#the-theme-maturity&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-theme-maturity&quot;&gt;&lt;/a&gt;The theme: Maturity&lt;/h1&gt;
&lt;p&gt;In short, 2019 will be a year of &lt;em&gt;rejuvenation&lt;/em&gt; and &lt;em&gt;maturation&lt;/em&gt; for the Rust
project. We shipped a lot of stuff last year, and grew a lot. Now it's time to
take a step back, take stock, and prepare for the future.&lt;/p&gt;
&lt;p&gt;The work we have planned for this year falls into three major categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Governance: improving how the project is run&lt;/li&gt;
&lt;li&gt;Finish long-standing requests: closing out work we've started but never finished&lt;/li&gt;
&lt;li&gt;Polish: improving the overall quality of the language and tooling&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#governance&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;governance&quot;&gt;&lt;/a&gt;Governance&lt;/h2&gt;
&lt;p&gt;Over the last three years, the Rust project has grown a lot. Rust used to have a core team of 8 members. When we added sub-teams in 2015, we grew to 23 members. We've now grown to over 100 — that's bigger than many companies! And of course, looking beyond the teams, the size of the Rust community as a whole has grown tremendously as well. As a result of this growth, we've found that the processes which served us well when we were a smaller project are starting to feel some strain.&lt;/p&gt;
&lt;p&gt;Many of the teams have announced plans to look over revamp their processes to scale better. Often this can be as simple as taking the time to write down things that previously were understood only informally — sometimes it means establishing new structures.&lt;/p&gt;
&lt;p&gt;Because of this widespread interest in governance, we've also created a new &lt;a href=&quot;https://internals.rust-lang.org/t/governance-working-group-announcement/9637&quot;&gt;&lt;strong&gt;Governance Working Group&lt;/strong&gt;&lt;/a&gt;. This group is going to be devoted to working with each team to hone its governance structure and to help pass lessons and strategies between teams.&lt;/p&gt;
&lt;p&gt;Additionally, the RFC process has been a great boon for Rust, but as we've grown, there have been times where it didn't work so well too.
We may look at revisions to the process this year.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#long-standing-requests&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;long-standing-requests&quot;&gt;&lt;/a&gt;Long-standing requests&lt;/h2&gt;
&lt;p&gt;There are a number of exciting initiatives that have been sitting in a limbo
state — the majority of the design is done, but there are some lingering
complications that we haven't had time to work out. This year we hope to take
a fresh look at some of these problems and try hard to resolve those
lingering problems.&lt;/p&gt;
&lt;p&gt;Examples include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Cargo team and custom registries&lt;/li&gt;
&lt;li&gt;The Language team is taking a look at async/await, specialization, const generics, and generic associated types&lt;/li&gt;
&lt;li&gt;The Libs team wants to finish custom allocators&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#polish&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;polish&quot;&gt;&lt;/a&gt;Polish&lt;/h2&gt;
&lt;p&gt;Finally, the last few years have also seen a lot of foundational work. The
compiler, for example, was massively refactored to support incremental
compilation and to be better prepared for IDEs. Now that we've got these
pieces in place, we want to do the “polish” work that really makes for a
great experience.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compile times and IDE support&lt;/li&gt;
&lt;li&gt;Polishing the specification of the language by improving &lt;a href=&quot;https://doc.rust-lang.org/stable/reference/&quot;&gt;the reference&lt;/a&gt; and laying out &lt;a href=&quot;https://github.com/rust-lang/unsafe-code-guidelines&quot;&gt;the unsafe code guidelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The WebAssembly WG's work this year includes polishing our wasm support, for example, debugging&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#conclusion&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This post only covered a few examples of the plans we've been making. &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md&quot;&gt;If you'd like to see the full details, take a look at the RFC itself.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here's to a great 2019 for Rust!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.34.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html" type="text/html" title="Announcing Rust 1.34.0" />
        <published>2019-04-11T00:00:00Z</published>
        <updated>2019-04-11T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.34.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.34.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate
page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.34.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.34.0-stable&quot;&gt;&lt;/a&gt;What's in 1.34.0 stable&lt;/h2&gt;
&lt;p&gt;The largest feature in this release is the introduction of &lt;em&gt;alternative&lt;/em&gt; &lt;code&gt;cargo&lt;/code&gt; registries.
The release also includes support for &lt;code&gt;?&lt;/code&gt; in documentation tests,
some improvements for &lt;code&gt;#[attribute(..)]&lt;/code&gt;s, as well as the stabilization of &lt;code&gt;TryFrom&lt;/code&gt;.
Read on for a few highlights, or see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1340-2019-04-11&quot;&gt;detailed release notes&lt;/a&gt; for additional information.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#alternative-cargo-registries&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;alternative-cargo-registries&quot;&gt;&lt;/a&gt;Alternative &lt;code&gt;cargo&lt;/code&gt; registries&lt;/h3&gt;
&lt;p&gt;Since before 1.0, Rust has had a public crate registry, &lt;a href=&quot;http://crates.io/&quot;&gt;crates.io&lt;/a&gt;.
People publish crates with &lt;code&gt;cargo publish&lt;/code&gt; and it's easy to include these crates
in the &lt;code&gt;[dependencies]&lt;/code&gt; section of your &lt;code&gt;Cargo.toml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, not everyone &lt;em&gt;wants&lt;/em&gt; to publish their crates to crates.io.
People maintaining proprietary/closed-source code cannot use crates.io,
and instead are forced to use &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;path&lt;/code&gt; dependencies.
This is usually fine for small projects, but if you have a lot of closed-source crates
within a large organization, you lose the benefit of the versioning support that crates.io has.&lt;/p&gt;
&lt;p&gt;With this release, Cargo gains support for alternate registries.
These registries coexist with crates.io, so you can write software that depends
on crates from both crates.io and your custom registry.
Crates on crates.io cannot however depend on external registries.&lt;/p&gt;
&lt;p&gt;To use an alternate registry, you must add these lines to your &lt;code&gt;.cargo/config&lt;/code&gt;.
This file can be in your home directory (&lt;code&gt;~/.cargo/config&lt;/code&gt;) or relative to the package directory.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[registries]
my-registry = { index = &amp;quot;https://my-intranet:8080/git/index&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Depending on a crate from an alternate registry is easy.
When specifying dependencies in your &lt;code&gt;Cargo.toml&lt;/code&gt;, use the &lt;code&gt;registry&lt;/code&gt; key to
let Cargo know that you wish to fetch the crate from the alternate registry:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies]
other-crate = { version = &amp;quot;1.0&amp;quot;, registry = &amp;quot;my-registry&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a crate author, if you wish to publish your crate to an alternate registry,
you first need to save the authentication token into &lt;code&gt;~/.cargo/credentials&lt;/code&gt; with the &lt;code&gt;cargo login&lt;/code&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;cargo login --registry=my-registry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can then use the &lt;code&gt;--registry&lt;/code&gt; flag to indicate which registry to use when publishing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;cargo publish --registry=my-registry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is &lt;a href=&quot;https://doc.rust-lang.org/nightly/cargo/reference/registries.html#running-a-registry&quot;&gt;documentation&lt;/a&gt; on how to run your own registry.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#-in-documentation-tests&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;-in-documentation-tests&quot;&gt;&lt;/a&gt;&lt;code&gt;?&lt;/code&gt; in documentation tests&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://rust-lang.github.io/rfcs/1937-ques-in-main.html&quot;&gt;RFC 1937&lt;/a&gt; proposed adding support for using the &lt;code&gt;?&lt;/code&gt; operator in &lt;code&gt;fn main()&lt;/code&gt;,
&lt;code&gt;#[test]&lt;/code&gt; functions, and doctests, allowing them to return &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;,
with error values causing a nonzero exit code in the case of &lt;code&gt;fn main()&lt;/code&gt;,
and a test failure in the case of the tests.&lt;/p&gt;
&lt;p&gt;Support in &lt;code&gt;fn main()&lt;/code&gt; and &lt;code&gt;#[test]&lt;/code&gt; was implemented &lt;a href=&quot;https://blog.rust-lang.org/2018/05/10/Rust-1.26.html#main-can-return-a-result&quot;&gt;many releases ago&lt;/a&gt;.
However, the support within documentation tests was limited to doctests that have an explicit &lt;code&gt;fn main()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this release, full support for &lt;code&gt;?&lt;/code&gt; in doctests has been added.
Now, you can write this in your documentation tests:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;/// ```rust
/// use std::io;
/// let mut input = String::new();
/// io::stdin().read_line(&amp;amp;mut input)?;
/// # Ok::&amp;lt;(), io::Error&amp;gt;(())
/// ```
fn my_func() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You still have to specify the error type being used at the bottom of the documentation test.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#custom-attributes-accept-arbitrary-token-streams&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;custom-attributes-accept-arbitrary-token-streams&quot;&gt;&lt;/a&gt;Custom attributes accept arbitrary token streams&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html&quot;&gt;Procedural macros&lt;/a&gt; in Rust can define custom attributes that they consume.
Until now, such attributes were restricted to being trees of paths and literals
according to a specific syntax, like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[foo(bar)]
#[foo = &amp;quot;bar&amp;quot;]
#[foo = 0]
#[foo(bar = true)]
#[foo(bar, baz(quux, foo = &amp;quot;bar&amp;quot;))]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unlike procedural macros, these helper attributes could not accept arbitrary token streams in delimiters,
so you could not write &lt;code&gt;#[range(0..10)]&lt;/code&gt; or &lt;code&gt;#[bound(T: MyTrait)]&lt;/code&gt;.
Procedural macro crates would instead use strings for specifying syntaxes like this, e.g. &lt;code&gt;#[range(&amp;quot;0..10&amp;quot;)]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;With this Rust release, custom attributes &lt;code&gt;#[attr($tokens)]&lt;/code&gt; &lt;a href=&quot;https://github.com/rust-lang/rust/pull/57367&quot;&gt;now accept&lt;/a&gt;
arbitrary token streams in &lt;code&gt;$tokens&lt;/code&gt;, bringing them on par with macros.
If you're the author of a procedural macro crate, please check if your custom attributes
have unnecessary strings in their syntax and if they can be better expressed with token streams.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#tryfrom-and-tryinto&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;tryfrom-and-tryinto&quot;&gt;&lt;/a&gt;&lt;code&gt;TryFrom&lt;/code&gt; and &lt;code&gt;TryInto&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/std/convert/trait.TryFrom.html&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/convert/trait.TryInto.html&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; traits were stabilized to allow fallible type conversions.&lt;/p&gt;
&lt;p&gt;For example, the &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.u32.html#method.from_be_bytes&quot;&gt;&lt;code&gt;from_be_bytes&lt;/code&gt;&lt;/a&gt; and related methods on integer types take arrays,
but data is often read in via slices. Converting between slices and arrays is tedious to do manually.
With the new traits, it can be done inline with &lt;code&gt;.try_into()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let num = u32::from_be_bytes(slice.try_into()?);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For conversions that cannot fail, such as &lt;code&gt;u8&lt;/code&gt; to &lt;code&gt;u32&lt;/code&gt;, the &lt;a href=&quot;https://doc.rust-lang.org/std/convert/enum.Infallible.html&quot;&gt;&lt;code&gt;Infallible&lt;/code&gt;&lt;/a&gt; type was added.
This also permits a blanket implementation of &lt;code&gt;TryFrom&lt;/code&gt; for all existing &lt;code&gt;From&lt;/code&gt; implementations.
In the future, we hope to turn &lt;code&gt;Infallible&lt;/code&gt; into an alias for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/35121&quot;&gt;the &lt;code&gt;!&lt;/code&gt; (never) type&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#fn-before_exec-deprecated-in-favor-of-unsafe-fn-pre_exec&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;fn-before_exec-deprecated-in-favor-of-unsafe-fn-pre_exec&quot;&gt;&lt;/a&gt;&lt;code&gt;fn before_exec&lt;/code&gt; deprecated in favor of &lt;code&gt;unsafe fn pre_exec&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;On Unix-like systems, the function &lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/process/trait.CommandExt.html#tymethod.before_exec&quot;&gt;&lt;code&gt;CommandExt::before_exec&lt;/code&gt;&lt;/a&gt; allows you to
schedule a closure to be run before &lt;code&gt;exec&lt;/code&gt; is invoked.&lt;/p&gt;
&lt;p&gt;The closure provided will be run in the context of the child process after a fork.
This means that resources, such as file descriptors and memory-mapped regions, may get duplicated.
In other words, you can now copy a value of a non-&lt;code&gt;Copy&lt;/code&gt; type into a different process
while retaining the original in the parent. This makes &lt;a href=&quot;https://github.com/rust-lang/rust/issues/39575#issuecomment-437658766&quot;&gt;it possible&lt;/a&gt; to cause
undefined behavior and break &lt;a href=&quot;https://github.com/rust-lang/rust/issues/39575#issuecomment-439645949&quot;&gt;libraries assuming non-duplication&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;before_exec&lt;/code&gt; should therefore have been marked as &lt;code&gt;unsafe&lt;/code&gt;.
In this release of Rust, we have deprecated &lt;code&gt;fn before_exec&lt;/code&gt; in favor of the &lt;code&gt;unsafe fn pre_exec&lt;/code&gt;.
When calling &lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/process/trait.CommandExt.html#tymethod.pre_exec&quot;&gt;&lt;code&gt;CommandExt::pre_exec&lt;/code&gt;&lt;/a&gt;, it is your responsibility to make sure that the closure
does not violate library invariants by making invalid use of these duplicates.
If you provide a library that is in a similar situation as &lt;code&gt;before_exec&lt;/code&gt;,
consider deprecating and providing an &lt;code&gt;unsafe&lt;/code&gt; alternative as well.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;In 1.34.0, the set of stable atomic integer types was expanded,
with signed and unsigned variants from 8 (&lt;a href=&quot;https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU8.html&quot;&gt;&lt;code&gt;AtomicU8&lt;/code&gt;&lt;/a&gt;) to 64 bits now available.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1280-2018-08-02&quot;&gt;Previously&lt;/a&gt;, non-zero unsigned integer types, e.g. &lt;a href=&quot;https://doc.rust-lang.org/std/num/struct.NonZeroU8.html&quot;&gt;&lt;code&gt;NonZeroU8&lt;/code&gt;&lt;/a&gt;, were stabilized.
This gave &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; the same size as &lt;code&gt;u8&lt;/code&gt;.
With this Rust release, signed versions, e.g. &lt;a href=&quot;https://doc.rust-lang.org/std/num/struct.NonZeroI8.html&quot;&gt;&lt;code&gt;NonZeroI8&lt;/code&gt;&lt;/a&gt;, have been stabilized.&lt;/p&gt;
&lt;p&gt;The functions &lt;a href=&quot;https://doc.rust-lang.org/std/iter/fn.from_fn.html&quot;&gt;&lt;code&gt;iter::from_fn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/iter/fn.successors.html&quot;&gt;&lt;code&gt;iter::successors&lt;/code&gt;&lt;/a&gt; have been stabilized.
The former allows you to construct an iterator from &lt;code&gt;FnMut() -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt;.
To pop elements from a vector iteratively, you can now write &lt;code&gt;from_fn(|| vec.pop())&lt;/code&gt;.
Meanwhile, the latter creates a new iterator where each successive item
is computed based on the preceding one.&lt;/p&gt;
&lt;p&gt;Additionally, these APIs have become stable:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/any/trait.Any.html#tymethod.type_id&quot;&gt;Any::type_id&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/error/trait.Error.html#method.type_id&quot;&gt;Error::type_id&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.sort_by_cached_key&quot;&gt;slice::sort_by_cached_key&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.escape_debug&quot;&gt;str::escape_debug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.escape_default&quot;&gt;str::escape_default&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.escape_unicode&quot;&gt;str::escape_unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.split_ascii_whitespace&quot;&gt;str::split_ascii_whitespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Instant.html#method.checked_add&quot;&gt;Instant::checked_add&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Instant.html#method.checked_sub&quot;&gt;Instant::checked_sub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.checked_add&quot;&gt;SystemTime::checked_add&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.checked_sub&quot;&gt;SystemTime::checked_sub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1340-2019-04-11&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.33.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html" type="text/html" title="Announcing Rust 1.33.0" />
        <published>2019-02-28T00:00:00Z</published>
        <updated>2019-02-28T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.33.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.33.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes for
1.33.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.33.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.33.0-stable&quot;&gt;&lt;/a&gt;What's in 1.33.0 stable&lt;/h2&gt;
&lt;p&gt;The two largest features in this release are significant improvements to
&lt;code&gt;const fn&lt;/code&gt;s, and the stabilization of a new concept: &amp;quot;pinning.&amp;quot;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#const-fn-improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;const-fn-improvements&quot;&gt;&lt;/a&gt;&lt;code&gt;const fn&lt;/code&gt; improvements&lt;/h3&gt;
&lt;p&gt;With &lt;code&gt;const fn&lt;/code&gt;, you can &lt;a href=&quot;https://github.com/rust-lang/rust/pull/57175/&quot;&gt;now do way more
things!&lt;/a&gt; Specifically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;irrefutable destructuring patterns (e.g. &lt;code&gt;const fn foo((x, y): (u8, u8)) { ... }&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt; bindings (e.g. &lt;code&gt;let x = 1;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;mutable &lt;code&gt;let&lt;/code&gt; bindings (e.g. &lt;code&gt;let mut x = 1;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;assignment (e.g. &lt;code&gt;x = y&lt;/code&gt;) and assignment operator (e.g. &lt;code&gt;x += y&lt;/code&gt;)
expressions, even where the assignment target is a projection (e.g. a struct
field or index operation like &lt;code&gt;x[3] = 42&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;expression statements (e.g. &lt;code&gt;3;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You're also &lt;a href=&quot;https://github.com/rust-lang/rust/pull/57067/&quot;&gt;able to call &lt;code&gt;const unsafe fn&lt;/code&gt;s inside a &lt;code&gt;const fn&lt;/code&gt;&lt;/a&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const unsafe fn foo() -&amp;gt; i32 { 5 }
const fn bar() -&amp;gt; i32 {
    unsafe { foo() }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With these additions, many more functions in the standard library are able to
be marked as &lt;code&gt;const&lt;/code&gt;. We'll enumerate those in the library section below.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#pinning&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;pinning&quot;&gt;&lt;/a&gt;Pinning&lt;/h3&gt;
&lt;p&gt;This release introduces a new concept for Rust programs, implemented as two
types: the &lt;a href=&quot;https://doc.rust-lang.org/std/pin/struct.Pin.html&quot;&gt;&lt;code&gt;std::pin::Pin&amp;lt;P&amp;gt;&lt;/code&gt;
type&lt;/a&gt;, and the &lt;a href=&quot;https://doc.rust-lang.org/std/marker/trait.Unpin.html&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;
marker trait&lt;/a&gt;. The core
idea is elaborated on in &lt;a href=&quot;https://doc.rust-lang.org/std/pin/index.html&quot;&gt;the docs for
&lt;code&gt;std::pin&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is sometimes useful to have objects that are guaranteed to not move, in
the sense that their placement in memory does not change, and can thus be
relied upon. A prime example of such a scenario would be building
self-referential structs, since moving an object with pointers to itself will
invalidate them, which could cause undefined behavior.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location
in memory, meaning it cannot be moved elsewhere and its memory cannot be
deallocated until it gets dropped. We say that the pointee is &amp;quot;pinned&amp;quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This feature will largely be used by library authors, and so we won't talk a
lot more about the details here. Consult the docs if you're interested in
digging into the details. However, the stabilization of this API is important
to Rust users generally because it is a significant step forward towards a
highly anticipated Rust feature: &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;. We're not quite there yet,
but this stabilization brings us one step closer. You can track all of the
necessary features at &lt;a href=&quot;https://areweasyncyet.rs/&quot;&gt;areweasyncyet.rs&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#import-as-_&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;import-as-_&quot;&gt;&lt;/a&gt;Import as &lt;code&gt;_&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56303/&quot;&gt;You can now import an item as
&lt;code&gt;_&lt;/code&gt;&lt;/a&gt;. This allows you to
import a trait's impls, and not have the name in the namespace. e.g.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::io::Read as _;

// Allowed as there is only one `Read` in the module.
pub trait Read {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;Here's all of the stuff that's been made &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57566&quot;&gt;The methods &lt;code&gt;overflowing_{add, sub, mul, shl, shr}&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt;
functions for all numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57105&quot;&gt;The methods &lt;code&gt;rotate_left&lt;/code&gt;, &lt;code&gt;rotate_right&lt;/code&gt;, and &lt;code&gt;wrapping_{add, sub, mul, shl, shr}&lt;/code&gt;
are now &lt;code&gt;const&lt;/code&gt; functions for all numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57105&quot;&gt;The methods &lt;code&gt;is_positive&lt;/code&gt; and &lt;code&gt;is_negative&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt; functions for
all signed numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57167&quot;&gt;The &lt;code&gt;get&lt;/code&gt; method for all &lt;code&gt;NonZero&lt;/code&gt; types is now &lt;code&gt;const&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57234&quot;&gt;The methods &lt;code&gt;count_ones&lt;/code&gt;, &lt;code&gt;count_zeros&lt;/code&gt;, &lt;code&gt;leading_zeros&lt;/code&gt;, &lt;code&gt;trailing_zeros&lt;/code&gt;,
&lt;code&gt;swap_bytes&lt;/code&gt;, &lt;code&gt;from_be&lt;/code&gt;, &lt;code&gt;from_le&lt;/code&gt;, &lt;code&gt;to_be&lt;/code&gt;, &lt;code&gt;to_le&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt; for all
numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57234&quot;&gt;&lt;code&gt;Ipv4Addr::new&lt;/code&gt; is now a &lt;code&gt;const&lt;/code&gt; function&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, these APIs have become stable:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.read_exact_at&quot;&gt;&lt;code&gt;unix::FileExt::read_exact_at&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.write_all_at&quot;&gt;&lt;code&gt;unix::FileExt::write_all_at&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose&quot;&gt;&lt;code&gt;Option::transpose&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose&quot;&gt;&lt;code&gt;Result::transpose&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/convert/fn.identity.html&quot;&gt;&lt;code&gt;convert::identity&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/pin/struct.Pin.html&quot;&gt;&lt;code&gt;pin::Pin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/marker/trait.Unpin.html&quot;&gt;&lt;code&gt;marker::Unpin&lt;/code&gt;&lt;/a&gt; (mentioned above)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/marker/struct.PhantomPinned.html&quot;&gt;&lt;code&gt;marker::PhantomPinned&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.resize_with&quot;&gt;&lt;code&gt;Vec::resize_with&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.resize_with&quot;&gt;&lt;code&gt;VecDeque::resize_with&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_millis&quot;&gt;&lt;code&gt;Duration::as_millis&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_micros&quot;&gt;&lt;code&gt;Duration::as_micros&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_nanos&quot;&gt;&lt;code&gt;Duration::as_nanos&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cargo-features&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cargo-features&quot;&gt;&lt;/a&gt;Cargo features&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/cargo/pull/6484/&quot;&gt;Cargo should now rebuild a crate if a file was modified during the initial
build.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cratesio&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cratesio&quot;&gt;&lt;/a&gt;Crates.io&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://users.rust-lang.org/t/a-verified-email-address-will-be-required-to-publish-to-crates-io-starting-on-2019-02-28/22425&quot;&gt;As previously announced&lt;/a&gt;, coinciding with this release, crates.io
will require that you have a verified email address to publish. Starting at
2019-03-01 00:00 UTC, if you don't have a verified email address and run &lt;code&gt;cargo publish&lt;/code&gt;, you'll get an error.&lt;/p&gt;
&lt;p&gt;This ensures we can comply with DMCA procedures. If you haven't heeded the
warnings cargo printed during the last release cycle, head on over to
&lt;a href=&quot;https://crates.io/me&quot;&gt;crates.io/me&lt;/a&gt; to set and verify your email address. This email address
will never be displayed publicly and will only be used for crates.io operations.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-133.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-133.0&quot;&gt;&lt;/a&gt;Contributors to 1.33.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.33.0. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.33.0&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Changes in the core team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/02/22/Core-team-changes.html" type="text/html" title="Changes in the core team" />
        <published>2019-02-22T00:00:00Z</published>
        <updated>2019-02-22T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/02/22/Core-team-changes.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/02/22/Core-team-changes.html">&lt;p&gt;Just a quick update: You may have noticed that, in the last month or
so, a number of &lt;a href=&quot;https://www.rust-lang.org/governance/teams/core&quot;&gt;Rust core team&lt;/a&gt; members have changed their jobs
and/or their roles in the project. Two people have decided to step
back from the core team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nick Cameron &lt;a href=&quot;https://www.ncameron.org/blog/leaving-mozilla-and-most-of-the-rust-project/&quot;&gt;left Mozilla to work at PingCap&lt;/a&gt;. Although he
won’t have time to stay active on the core team, he plans to
continue co-leading the Cargo team in his new position.&lt;/li&gt;
&lt;li&gt;Aaron Turon &lt;a href=&quot;https://internals.rust-lang.org/t/aturon-retires-from-the-core-team-but-not-from-rust/9392/3&quot;&gt;decided to step back from the core team&lt;/a&gt; so
that he could focus on engineering work and the language design
team. (He remains on the Rust team at Mozilla.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With Rust 2018 having shipped, this is a natural time of
transition. While we’ll miss Nick and Aaron’s contributions to the
core team, we are very excited for them to be focusing on something
new, and we’re very happy that they are still going to stay involved
with Rust. We’re also looking into growing the core team to help with
the work ahead.&lt;/p&gt;
&lt;p&gt;Finally, two other members have changed their jobs, but plan to stay
involved in the core team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ashley Williams &lt;a href=&quot;https://twitter.com/ag_dubs/status/1088118810157219848&quot;&gt;joined Cloudflare and plans to work on Rust and WASM integration there&lt;/a&gt;.
She will be remaining on the core team.&lt;/li&gt;
&lt;li&gt;Steve Klabnik &lt;a href=&quot;https://words.steveklabnik.com/thank-u-next&quot;&gt;left Mozilla, but will remain on the core team.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That’s it!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.32.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html" type="text/html" title="Announcing Rust 1.32.0" />
        <published>2019-01-17T00:00:00Z</published>
        <updated>2019-01-17T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.32.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.32.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes for
1.32.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As a small side note, &lt;code&gt;rustup&lt;/code&gt; has seen some new releases lately! To update
&lt;code&gt;rustup&lt;/code&gt; itself, run &lt;code&gt;rustup self update&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.32.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.32.0-stable&quot;&gt;&lt;/a&gt;What's in 1.32.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.32.0 has a few quality of life improvements, switches the default
allocator, and makes additional functions &lt;code&gt;const&lt;/code&gt;. Read on for a few
highlights, or see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes&lt;/a&gt; for additional
information.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#the-dbg-macro&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-dbg-macro&quot;&gt;&lt;/a&gt;The &lt;code&gt;dbg&lt;/code&gt; macro&lt;/h4&gt;
&lt;p&gt;First up, a quality of life improvement. Are you a &amp;quot;print debugger&amp;quot;? If you are, and
you've wanted to print out some value while working on some code, you have to do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let x = 5;

println!(&amp;quot;{:?}&amp;quot;, x);

// or maybe even this
println!(&amp;quot;{:#?}&amp;quot;, x);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This isn't the &lt;em&gt;largest&lt;/em&gt; speed bump, but it is a lot of stuff to simply show the value of &lt;code&gt;x&lt;/code&gt;.
Additionally, there's no context here. If you have several of these &lt;code&gt;println!&lt;/code&gt;s, it can be hard
to tell which is which, unless you add your own context to each invocation, requiring even more work.&lt;/p&gt;
&lt;p&gt;In Rust 1.32.0, &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56395/&quot;&gt;we've added a new macro,
&lt;code&gt;dbg!&lt;/code&gt;&lt;/a&gt;, for this purpose:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let x = 5;
    
    dbg!(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run this program, you'll see:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[src/main.rs:4] x = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You get the file and line number of where this was invoked, as well as the
name and value. Additionally, &lt;code&gt;println!&lt;/code&gt; prints to the standard output, so
you really should be using &lt;code&gt;eprintln!&lt;/code&gt; to print to standard error. &lt;code&gt;dbg!&lt;/code&gt;
does the right thing and goes to &lt;code&gt;stderr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It even works in more complex circumstances. Consider this factorial example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn factorial(n: u32) -&amp;gt; u32 {
    if n &amp;lt;= 1 {
        n
    } else {
        n * factorial(n - 1)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we wanted to debug this, we might write it like this with &lt;code&gt;eprintln!&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn factorial(n: u32) -&amp;gt; u32 {
    eprintln!(&amp;quot;n: {}&amp;quot;, n);

    if n &amp;lt;= 1 {
        eprintln!(&amp;quot;n &amp;lt;= 1&amp;quot;);

        n
    } else {
        let n = n * factorial(n - 1);

        eprintln!(&amp;quot;n: {}&amp;quot;, n);

        n
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We want to log &lt;code&gt;n&lt;/code&gt; on each iteration, as well as have some kind of context
for each of the branches. We see this output for &lt;code&gt;factorial(4)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;n: 4
n: 3
n: 2
n: 1
n &amp;lt;= 1
n: 2
n: 6
n: 24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is servicable, but not particularly great. Maybe we could work on how we
print out the context to make it more clear, but now we're not debugging our code,
we're figuring out how to make our debugging code better.&lt;/p&gt;
&lt;p&gt;Consider this version using &lt;code&gt;dbg!&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn factorial(n: u32) -&amp;gt; u32 {
    if dbg!(n &amp;lt;= 1) {
        dbg!(1)
    } else {
        dbg!(n * factorial(n - 1))
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We simply wrap each of the various expressions we want to print with the macro. We
get this output instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[src/main.rs:3] n &amp;lt;= 1 = false
[src/main.rs:3] n &amp;lt;= 1 = false
[src/main.rs:3] n &amp;lt;= 1 = false
[src/main.rs:3] n &amp;lt;= 1 = true
[src/main.rs:4] 1 = 1
[src/main.rs:5] n * factorial(n - 1) = 2
[src/main.rs:5] n * factorial(n - 1) = 6
[src/main.rs:5] n * factorial(n - 1) = 24
[src/main.rs:11] factorial(4) = 24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because the &lt;code&gt;dbg!&lt;/code&gt; macro returns the value of what it's debugging, instead of
&lt;code&gt;eprintln!&lt;/code&gt; which returns &lt;code&gt;()&lt;/code&gt;, we need to make &lt;em&gt;no&lt;/em&gt; changes to the structure
of our code. Additionally, we have &lt;em&gt;vastly&lt;/em&gt; more useful output.&lt;/p&gt;
&lt;p&gt;That's a lot to say about a little macro, but we hope it improves your
debugging experience! We are contining to work on support for &lt;code&gt;gdb&lt;/code&gt; and
friends as well, of course.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#jemalloc-is-removed-by-default&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;jemalloc-is-removed-by-default&quot;&gt;&lt;/a&gt;&lt;code&gt;jemalloc&lt;/code&gt; is removed by default&lt;/h4&gt;
&lt;p&gt;Long, long ago, Rust had a large, Erlang-like runtime. We chose to use
&lt;a href=&quot;http://jemalloc.net/&quot;&gt;jemalloc&lt;/a&gt; instead of the system allocator, because it often improved
performance over the default system one. Over time, we shed more and more of
this runtime, and eventually almost all of it was removed, but jemalloc
was not. We didn't have a way to choose a custom allocator, and so we
couldn't really remove it without causing a regression for people who do need
jemalloc.&lt;/p&gt;
&lt;p&gt;Also, saying that &lt;code&gt;jemalloc&lt;/code&gt; was always the default is a bit UNIX-centric,
as it was only the default on &lt;em&gt;some&lt;/em&gt; platforms. Notably, the MSVC target on
Windows has shipped the system allocator for a long time.&lt;/p&gt;
&lt;p&gt;Finally, while jemalloc &lt;em&gt;usually&lt;/em&gt; has great performance, that's not always
the case. Additionally, it adds about 300kb to every Rust binary. We've also
had a host of &lt;a href=&quot;https://github.com/rust-lang/rust/issues/36963#issuecomment-252029017&quot;&gt;other
issues&lt;/a&gt;
with jemalloc in the past. It has also felt a little strange that a systems
language does not default to the system's allocator.&lt;/p&gt;
&lt;p&gt;For all of these reasons, once &lt;a href=&quot;https://blog.rust-lang.org/2018/08/02/Rust-1.28.html#whats-in-1.28.0-stable&quot;&gt;Rust 1.28 shipped a way to choose a global
allocator&lt;/a&gt;,
we started making plans to switch the default to the system allocator, and
allow you to use &lt;code&gt;jemalloc&lt;/code&gt; via a crate. In Rust 1.32, we've finally finished
this work, and by default, you will get the system allocator for your
programs.&lt;/p&gt;
&lt;p&gt;If you'd like to continue to use jemalloc, use &lt;a href=&quot;https://crates.io/crates/jemallocator&quot;&gt;the jemallocator crate&lt;/a&gt;. In
your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;jemallocator = &amp;quot;0.1.8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in your crate root:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's it! If you don't need jemalloc, it's not forced upon you, and if
you do need it, it's a few lines of code away.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#final-module-improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;final-module-improvements&quot;&gt;&lt;/a&gt;Final module improvements&lt;/h4&gt;
&lt;p&gt;In the past two releases, we announced several improvements to the module
system. We have one last tweak landing in 1.32.0 and the 2018 edition.
Nicknamed &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56759#issuecomment-450051210&quot;&gt;&amp;quot;uniform
paths&amp;quot;&lt;/a&gt;,
it permits previously invalid import path statements to be resolved exactly
the same way as non-import paths. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;enum Color { Red, Green, Blue }

use Color::*;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code did &lt;em&gt;not&lt;/em&gt; previously compile, as &lt;code&gt;use&lt;/code&gt; statements had to start with
&lt;code&gt;super&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, or &lt;code&gt;crate&lt;/code&gt;. Now that the compiler supports uniform paths,
this code will work, and do what you probably expect: import the variants of
the &lt;code&gt;Color&lt;/code&gt; enum defined above the &lt;code&gt;use&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;With this change in place, we've completed our efforts at revising the module
system. We hope you've been enjoying the simplified system so far!&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#macro-improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;macro-improvements&quot;&gt;&lt;/a&gt;Macro improvements&lt;/h4&gt;
&lt;p&gt;A few improvements to macros have landed in Rust 1.32.0. First, &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56072/&quot;&gt;a new
&lt;code&gt;literal&lt;/code&gt; matcher&lt;/a&gt; was added:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;macro_rules! m {
    ($lt:literal) =&amp;gt; {};
}

fn main() {
    m!(&amp;quot;some string literal&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;literal&lt;/code&gt; matches against literals of any type; string literals, numeric literals, &lt;code&gt;char&lt;/code&gt; literals.&lt;/p&gt;
&lt;p&gt;In the 2018 edition, &lt;code&gt;macro_rules&lt;/code&gt; macros can also use &lt;code&gt;?&lt;/code&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;macro_rules! bar {
    ($(a)?) =&amp;gt; {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;?&lt;/code&gt; will match zero or one repetitions of the pattern, similar to the
already-existing &lt;code&gt;*&lt;/code&gt; for &amp;quot;zero or more&amp;quot; and &lt;code&gt;+&lt;/code&gt; for &amp;quot;one or more.&amp;quot;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;We talked above about the &lt;code&gt;dbg!&lt;/code&gt; macro, which is a big library addition.
Beyond that, 19 functions were made &lt;code&gt;const fn&lt;/code&gt;s, and all integral numeric
primitives now provide conversion functions to and from byte-arrays with
specified endianness. These six functions are named &lt;code&gt;to_&amp;lt;endian&amp;gt;_bytes&lt;/code&gt; and
&lt;code&gt;from_&amp;lt;endian&amp;gt;_bytes&lt;/code&gt;, where &lt;code&gt;&amp;lt;endian&amp;gt;&lt;/code&gt; is one of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ne&lt;/code&gt; - native endianness&lt;/li&gt;
&lt;li&gt;&lt;code&gt;le&lt;/code&gt; - little endian&lt;/li&gt;
&lt;li&gt;&lt;code&gt;be&lt;/code&gt; - big endian&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cargo-features&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cargo-features&quot;&gt;&lt;/a&gt;Cargo features&lt;/h3&gt;
&lt;p&gt;Cargo gained &lt;a href=&quot;https://github.com/rust-lang/cargo/pull/6218/&quot;&gt;&lt;code&gt;cargo c&lt;/code&gt; as an alias for &lt;code&gt;cargo check&lt;/code&gt;&lt;/a&gt;, and now &lt;a href=&quot;https://github.com/rust-lang/cargo/pull/6242/&quot;&gt;allows
usernames in registry URLs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-132.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-132.0&quot;&gt;&lt;/a&gt;Contributors to 1.32.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.32.0. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.32.0&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Procedural Macros in Rust 2018</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html" type="text/html" title="Procedural Macros in Rust 2018" />
        <published>2018-12-21T00:00:00Z</published>
        <updated>2018-12-21T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html">&lt;p&gt;Perhaps my favorite feature in the Rust 2018 edition is &lt;a href=&quot;https://doc.rust-lang.org/reference/procedural-macros.html&quot;&gt;procedural macros&lt;/a&gt;.
Procedural macros have had a long and storied history in Rust (and will continue
to have a storied future!), and now is perhaps one of the best times to get
involved with them because the 2018 edition has so dramatically improved the
experience both defining and using them.&lt;/p&gt;
&lt;p&gt;Here I'd like to explore what procedural macros are, what they're capable of,
notable new features, and some fun use cases of procedural macros. I might even
convince you that this is Rust 2018's best feature as well!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#what-is-a-procedural-macro&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-is-a-procedural-macro&quot;&gt;&lt;/a&gt;What is a procedural macro?&lt;/h3&gt;
&lt;p&gt;First defined over two years ago in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1566-proc-macros.md&quot;&gt;RFC 1566&lt;/a&gt;, procedural macros are, in
layman's terms, a function that takes a piece of syntax at compile time and
produces a new bit of syntax. Procedural macros in Rust 2018 come in one of
three flavors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#[derive]&lt;/code&gt; mode macros&lt;/strong&gt; have actually been stable since &lt;a href=&quot;https://blog.rust-lang.org/2017/02/02/Rust-1.15.html&quot;&gt;Rust 1.15&lt;/a&gt;
and bring all the goodness and ease of use of &lt;code&gt;#[derive(Debug)]&lt;/code&gt; to
user-defined traits as well, such as &lt;a href=&quot;https://serde.rs&quot;&gt;Serde&lt;/a&gt;'s &lt;code&gt;#[derive(Deserialize)]&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Function-like macros&lt;/strong&gt; are newly stable to the 2018 edition and allow
defining macros like &lt;code&gt;env!(&amp;quot;FOO&amp;quot;)&lt;/code&gt; or &lt;code&gt;format_args!(&amp;quot;...&amp;quot;)&lt;/code&gt; in a
crates.io-based library. You can think of these as sort of &amp;quot;&lt;code&gt;macro_rules!&lt;/code&gt;
macros&amp;quot; on steroids.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Attribute macros&lt;/strong&gt;, my favorite, are also new in the 2018 edition
and allow you to provide lightweight annotations on Rust functions which
perform syntactical transformations over the code at compile time.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each of these flavors of macros can be defined in a crate with &lt;code&gt;proc-macro = true&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/manifest.html&quot;&gt;specified in its manifest&lt;/a&gt;. When used, a procedural macro is
loaded by the Rust compiler and executed as the invocation is expanded. This
means that Cargo is in control of versioning for procedural macros and you can
use them with all same ease of use you'd expect from other Cargo dependencies!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#defining-a-procedural-macro&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;defining-a-procedural-macro&quot;&gt;&lt;/a&gt;Defining a procedural macro&lt;/h3&gt;
&lt;p&gt;Each of the three types of procedural macros are &lt;a href=&quot;https://doc.rust-lang.org/stable/reference/procedural-macros.html&quot;&gt;defined in a slightly different
fashion&lt;/a&gt;, and here we'll single out attribute macros. First, we'll flag
&lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[lib]
proc-macro = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then in &lt;code&gt;src/lib.rs&lt;/code&gt; we can write our macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn hello(attr: TokenStream, item: TokenStream) -&amp;gt; TokenStream {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then write some unit tests in &lt;code&gt;tests/smoke.rs&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[my_crate::hello]
fn wrapped_function() {}

#[test]
fn works() {
    wrapped_function();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... and that's it! When we execute &lt;code&gt;cargo test&lt;/code&gt; Cargo will compile our
procedural macro. Afterwards it will compile our unit test which loads the macro
at compile time, executing the &lt;code&gt;hello&lt;/code&gt; function and compiling the resulting
syntax.&lt;/p&gt;
&lt;p&gt;Right off the bat we can see a few important properties of procedural macros:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The input/output is this fancy &lt;code&gt;TokenStream&lt;/code&gt; type we'll talk about more in a
bit&lt;/li&gt;
&lt;li&gt;We're &lt;em&gt;executing arbitrary code&lt;/em&gt; at compile time, which means we can do just
about anything!&lt;/li&gt;
&lt;li&gt;Procedural macros are incorporated with the module system, meaning they can
be imported just like any other name.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before we take a look at implementing a procedural macro, let's first dive into
some of these points.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#macros-and-the-module-system&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;macros-and-the-module-system&quot;&gt;&lt;/a&gt;Macros and the module system&lt;/h3&gt;
&lt;p&gt;First stabilized in &lt;a href=&quot;https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html&quot;&gt;Rust 1.30&lt;/a&gt; (noticing a trend with 1.15?) macros are now
integrated with the module system in Rust. This mainly means that you no longer
need the clunky &lt;code&gt;#[macro_use]&lt;/code&gt; attribute when importing macros! Instead of this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[macro_use]
extern crate log;

fn main() {
    debug!(&amp;quot;hello, &amp;quot;);
    info!(&amp;quot;world!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;you can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use log::info;

fn main() {
    log::debug!(&amp;quot;hello, &amp;quot;);
    info!(&amp;quot;world!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Integration with the module system solves one of the most confusing parts about
macros historically. They're now imported and namespaced just as you would any
other item in Rust!&lt;/p&gt;
&lt;p&gt;The benefits are not only limited to bang-style &lt;code&gt;macro_rules&lt;/code&gt; macros, as you can
now transform code that looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[macro_use]
extern crate serde_derive;

#[derive(Deserialize)]
struct Foo {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;into&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use serde::Deserialize;

#[derive(Deserialize)]
struct Foo {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and you don't even need to explicitly depend on &lt;code&gt;serde_derive&lt;/code&gt; in &lt;code&gt;Cargo.toml&lt;/code&gt;!
All you need is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies]
serde = { version = '1.0.82', features = ['derive'] }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#whats-inside-a-tokenstream?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-inside-a-tokenstream?&quot;&gt;&lt;/a&gt;What's inside a &lt;code&gt;TokenStream&lt;/code&gt;?&lt;/h3&gt;
&lt;p&gt;This mysterious &lt;code&gt;TokenStream&lt;/code&gt; type comes from the &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/&quot;&gt;compiler-provided
&lt;code&gt;proc_macro&lt;/code&gt; crate&lt;/a&gt;. When it was first added all you could do with a
&lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; was call convert it to or from a string using &lt;code&gt;to_string()&lt;/code&gt; or &lt;code&gt;parse()&lt;/code&gt;.
As of Rust 2018, you can act on the tokens in a &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; directly.&lt;/p&gt;
&lt;p&gt;A &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is effectively &amp;quot;just&amp;quot; an iterator over &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/enum.TokenTree.html&quot;&gt;&lt;code&gt;TokenTree&lt;/code&gt;&lt;/a&gt;. All
syntax in Rust falls into one of these four categories, the four variants of
&lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/enum.TokenTree.html&quot;&gt;&lt;code&gt;TokenTree&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ident&lt;/code&gt; is any identifier like &lt;code&gt;foo&lt;/code&gt; or &lt;code&gt;bar&lt;/code&gt;. This also contains keywords
such as &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;super&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Literal&lt;/code&gt; include things like &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;, and &lt;code&gt;'b'&lt;/code&gt;. All literals are one
token and represent constant values in a program.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Punct&lt;/code&gt; represents some form of punctuation that's not a delimiter. For
example &lt;code&gt;.&lt;/code&gt; is a &lt;code&gt;Punct&lt;/code&gt; token in the field access of &lt;code&gt;foo.bar&lt;/code&gt;.
Multi-character punctuation like &lt;code&gt;=&amp;gt;&lt;/code&gt; is represented as two &lt;code&gt;Punct&lt;/code&gt; tokens,
one for &lt;code&gt;=&lt;/code&gt; and one for &lt;code&gt;&amp;gt;&lt;/code&gt;, and the &lt;code&gt;Spacing&lt;/code&gt; enum says that the &lt;code&gt;=&lt;/code&gt; is
adjacent to the &lt;code&gt;&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Group&lt;/code&gt; is where the term &amp;quot;tree&amp;quot; is most relevant, as &lt;code&gt;Group&lt;/code&gt; represents a
delimited sub-token-stream. For example &lt;code&gt;(a, b)&lt;/code&gt; is a &lt;code&gt;Group&lt;/code&gt; with parentheses
as delimiters, and the internal token stream is &lt;code&gt;a, b&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While this is conceptually simple, this may sound like there's not much we can
do with this! It's unclear, for example, how we might parse a function from a
&lt;code&gt;TokenStream&lt;/code&gt;. The minimality of &lt;code&gt;TokenTree&lt;/code&gt; is crucial, however, for
stabilization. It would be infeasible to stabilize the Rust AST because that
means we could never change it. (imagine if we couldn't have added the &lt;code&gt;?&lt;/code&gt;
operator!)&lt;/p&gt;
&lt;p&gt;By using &lt;code&gt;TokenStream&lt;/code&gt; to communicate with procedural macros, the compiler is
able to add new language syntax while also being able to compile
and work with older procedural macros. Let's see now, though, how we can
actually get useful information out of a &lt;code&gt;TokenStream&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#parsing-a-tokenstream&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;parsing-a-tokenstream&quot;&gt;&lt;/a&gt;Parsing a &lt;code&gt;TokenStream&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;If &lt;code&gt;TokenStream&lt;/code&gt; is just a simple iterator, then we've got a long way to go from
that to an actual parsed function. Although the code is already lexed for us
we still need to write a whole Rust parser! Thankfully though the community has
been hard at work to make sure writing procedural macros in Rust is as smooth as
can be, so you need look no further than the &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt; crate&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With the &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt; crate we can parse any Rust AST as a one-liner:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[proc_macro_attribute]
pub fn hello(attr: TokenStream, item: TokenStream) -&amp;gt; TokenStream {
    let input = syn::parse_macro_input!(item as syn::ItemFn);
    let name = &amp;amp;input.ident;
    let abi = &amp;amp;input.abi;
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt; crate not only comes with the ability to parse built-in syntax
but you can also easily write a recursive descent parser for your own syntax.
The &lt;a href=&quot;https://docs.rs/syn/0.15/syn/parse/index.html&quot;&gt;&lt;code&gt;syn::parse&lt;/code&gt; module&lt;/a&gt; has more information about this capability.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#producing-a-tokenstream&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;producing-a-tokenstream&quot;&gt;&lt;/a&gt;Producing a &lt;code&gt;TokenStream&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Not only do we take a &lt;code&gt;TokenStream&lt;/code&gt; as input with a procedural macro, but we
also need to produce a &lt;code&gt;TokenStream&lt;/code&gt; as output. This output is typically
required to be valid Rust syntax, but like the input it's just list of tokens
that we need to build somehow.&lt;/p&gt;
&lt;p&gt;Technically the only way to create a &lt;code&gt;TokenStream&lt;/code&gt; is via its &lt;code&gt;FromIterator&lt;/code&gt;
implementation, which means we'd have to create each token one-by-one and
collect it into a &lt;code&gt;TokenStream&lt;/code&gt;. This is quite tedious, though, so let's take a
look at &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;'s sibling crate: &lt;a href=&quot;https://docs.rs/quote/0.6/quote/&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.rs/quote/0.6/quote/&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt; crate is a quasi-quoting implementation for Rust which primarily
provides a convenient macro for us to use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use quote::quote;

#[proc_macro_attribute]
pub fn hello(attr: TokenStream, item: TokenStream) -&amp;gt; TokenStream {
    let input = syn::parse_macro_input!(item as syn::ItemFn);
    let name = &amp;amp;input.ident;

    // Our input function is always equivalent to returning 42, right?
    let result = quote! {
        fn #name() -&amp;gt; u32 { 42 }
    };
    result.into()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.rs/quote/0.6/quote/macro.quote.html&quot;&gt;&lt;code&gt;quote!&lt;/code&gt; macro&lt;/a&gt; allows you to write mostly-Rust syntax and interpolate
variables quickly from the environment with &lt;code&gt;#foo&lt;/code&gt;. This removes much of the
tedium of creating a &lt;code&gt;TokenStream&lt;/code&gt; token-by-token and allows quickly cobbling
together various pieces of syntax into one return value.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#tokens-and-span&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;tokens-and-span&quot;&gt;&lt;/a&gt;Tokens and &lt;code&gt;Span&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Perhaps the greatest feature of procedural macros in Rust 2018 is the ability to
customize and use &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; information on each token, giving us the ability for
amazing syntactical error messages from procedural macros:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: expected `fn`
 --&amp;gt; src/main.rs:3:14
  |
3 | my_annotate!(not_fn foo() {});
  |              ^^^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;as well as completely custom error messages:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: imported methods must have at least one argument
  --&amp;gt; invalid-imports.rs:12:5
   |
12 |     fn f1();
   |     ^^^^^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; can be thought of as a pointer back into an original source file,
typically saying something like &amp;quot;the &lt;code&gt;Ident&lt;/code&gt; token&lt;code&gt; foo&lt;/code&gt; came from file
&lt;code&gt;bar.rs&lt;/code&gt;, line 4, column 5, and was 3 bytes long&amp;quot;. This information is
primarily used by the compiler's diagnostics with warnings and error messages.&lt;/p&gt;
&lt;p&gt;In Rust 2018 each &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/enum.TokenTree.html&quot;&gt;&lt;code&gt;TokenTree&lt;/code&gt;&lt;/a&gt; has a &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; associated with it. This means that
if you preserve the &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; of all input tokens into the output then even
though you're producing brand new syntax the compiler's error messages are still
accurate!&lt;/p&gt;
&lt;p&gt;For example, a small macro like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[proc_macro]
pub fn make_pub(item: TokenStream) -&amp;gt; TokenStream {
    let result = quote! {
        pub #item
    };
    result.into()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;when invoked as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;my_macro::make_pub! {
    static X: u32 = &amp;quot;foo&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;is invalid because we're returning a string from a function that should return a
&lt;code&gt;u32&lt;/code&gt;, and the compiler will helpfully diagnose the problem as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0308]: mismatched types
 --&amp;gt; src/main.rs:1:37
  |
1 | my_macro::make_pub!(static X: u32 = &amp;quot;foo&amp;quot;);
  |                                     ^^^^^ expected u32, found reference
  |
  = note: expected type `u32`
             found type `&amp;amp;'static str`

error: aborting due to previous error

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can see here that although we're generating brand new syntax, the
compiler can preserve span information to continue to provide targeted
diagnostics about code that we've written.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#procedural-macros-in-the-wild&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;procedural-macros-in-the-wild&quot;&gt;&lt;/a&gt;Procedural Macros in the Wild&lt;/h3&gt;
&lt;p&gt;Ok up to this point we've got a pretty good idea about what procedural macros
can do and the various capabilities they have in the 2018 edition. As such a
long-awaited feature, the ecosystem is already making use of these new
capabilities! If you're interested, some projects to keep your eyes on are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.rs/quote/0.6/quote/&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.rs/proc-macro2/0.4/proc_macro2/&quot;&gt;&lt;code&gt;proc-macro2&lt;/code&gt;&lt;/a&gt; are your go-to libraries for
writing procedural macros. They make it easy to define custom parsers, parse
existing syntax, create new syntax, work with older versions of Rust, and much
more!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://serde.rs&quot;&gt;Serde&lt;/a&gt; and its derive macros for &lt;code&gt;Serialize&lt;/code&gt; and &lt;code&gt;Deserialize&lt;/code&gt; are likely the
most used macros in the ecosystem. They sport an &lt;a href=&quot;https://serde.rs/attributes.html&quot;&gt;impressive amount of
configuration&lt;/a&gt; and are a great example of how small annotations
can be so powerful.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/rustwasm/wasm-bindgen&quot;&gt;&lt;code&gt;wasm-bindgen&lt;/code&gt; project&lt;/a&gt; uses attribute macros to easily define
interfaces in Rust and import interfaces from JS. The &lt;code&gt;#[wasm_bindgen]&lt;/code&gt;
lightweight annotation makes it easy to understand what's coming in and out,
as well as removing lots of conversion boilerplate.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://gitlab.gnome.org/federico/gnome-class&quot;&gt;&lt;code&gt;gobject_gen!&lt;/code&gt; macro&lt;/a&gt; is an experimental IDL for the GNOME
project to define GObject objects safely in Rust, eschewing manually writing
all the glue necessary to talk to C and interface with other GObject
instances in Rust.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://rocket.rs/&quot;&gt;Rocket framework&lt;/a&gt; has recently switched over to procedural
macros, and showcases some of nightly-only features of procedural macros like
custom diagnostics, custom span creation, and more. Expect to see these
features stabilize in 2019!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That's just a &lt;em&gt;taste&lt;/em&gt; of the power of procedural macros and some example usage
throughout the ecosystem today. We're only 6 weeks out from the original release
of procedural macros on stable, so we've surely only scratched the surface as
well! I'm really excited to see where we can take Rust with procedural macros by
empowering all kinds of lightweight additions and extensions to the language!&lt;/p&gt;
</content>

        <author>
            <name>Alex Crichton</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.31.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/20/Rust-1.31.1.html" type="text/html" title="Announcing Rust 1.31.1" />
        <published>2018-12-20T00:00:00Z</published>
        <updated>2018-12-20T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/20/Rust-1.31.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/20/Rust-1.31.1.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.31.1. Rust is a
systems programming language focused on safety, speed, and concurrency.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.31.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1311-2018-12-20&quot;&gt;detailed release notes for
1.31.1&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.31.1-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.31.1-stable&quot;&gt;&lt;/a&gt;What's in 1.31.1 stable&lt;/h2&gt;
&lt;p&gt;This patch release fixes a build failure on &lt;code&gt;powerpc-unknown-netbsd&lt;/code&gt; by
way of &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56562&quot;&gt;an update to the &lt;code&gt;libc&lt;/code&gt;
crate&lt;/a&gt; used by the compiler.&lt;/p&gt;
&lt;p&gt;Additionally, the Rust Language Server was updated to fix two critical bugs.
First, &lt;a href=&quot;https://github.com/rust-lang/rls/pull/1170&quot;&gt;hovering over the type with documentation above single-line
attributes led to 100% CPU
usage:&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;/// Some documentation
#[derive(Debug)] // Multiple, single-line
#[allow(missing_docs)] // attributes
pub struct MyStruct { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rls/pull/1171&quot;&gt;Go to definition was fixed for std types&lt;/a&gt;:
Before, using the RLS on &lt;code&gt;HashMap&lt;/code&gt;, for example, tried to open this file&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/libstd/collections/hash/map.rs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and now RLS goes to the correct location (for Rust 1.31, note the extra &lt;code&gt;src&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/collections/hash/map.rs
&lt;/code&gt;&lt;/pre&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Tools in the 2018 edition</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/17/Rust-2018-dev-tools.html" type="text/html" title="Tools in the 2018 edition" />
        <published>2018-12-17T00:00:00Z</published>
        <updated>2018-12-17T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/17/Rust-2018-dev-tools.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/17/Rust-2018-dev-tools.html">&lt;p&gt;Tooling is an important part of what makes a programming language practical and
productive. Rust has always had some great tools (Cargo in particular has a
well-deserved reputation as a best-in-class package manager and build tool), and
the 2018 edition includes more tools which we hope further improve Rust users'
experience.&lt;/p&gt;
&lt;p&gt;In this blog post I'll cover Clippy and Rustfmt – two tools that have been
around for a few years and are now stable and ready for general use. I'll also
cover IDE support – a key workflow for many users which is now much better
supported. I'll start by talking about Rustfix, a new tool which was central to
our edition migration plans.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rustfix&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rustfix&quot;&gt;&lt;/a&gt;Rustfix&lt;/h2&gt;
&lt;p&gt;Rustfix is a tool for automatically making changes to Rust code. It is a key
part of our migration story for the 2018 edition, making the transition from
2015 to 2018 editions much easier, and in many cases completely automatic. This
is essential, since without such a tool we'd be much more limited in the kinds
of breaking changes users would accept.&lt;/p&gt;
&lt;p&gt;A simple example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;trait Foo {
    fn foo(&amp;amp;self, i32);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above is legal in Rust 2015, but not in Rust 2018 (method arguments must be
made explicit). Rustfix changes the above code to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;trait Foo {
    fn foo(&amp;amp;self, _: i32);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For detailed information on how to use Rustfix, see &lt;a href=&quot;https://doc.rust-lang.org/stable/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html&quot;&gt;these instructions&lt;/a&gt;.
To transition your code from the 2015 to 2018 edition, run &lt;code&gt;cargo fix --edition&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Rustfix can do a lot, but it is not perfect. When it can't fix your code, it
will emit a warning informing you that you need to fix it manually. We're
continuing to work to improve things.&lt;/p&gt;
&lt;p&gt;Rustfix works by automatically applying suggestions from the compiler. When we
add or improve the compiler's suggestion for fixing an error or warning, then
that improves Rustfix. We use the same information in an IDE to give quick fixes
(such as automatically adding imports).&lt;/p&gt;
&lt;p&gt;Thank you to Pascal Hertleif (killercup), Oliver Scherer (oli-obk), Alex
Crichton, Zack Davis, and Eric Huss for developing Rustfix and the compiler
lints which it uses.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#clippy&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;clippy&quot;&gt;&lt;/a&gt;Clippy&lt;/h2&gt;
&lt;p&gt;Clippy is a linter for Rust. It has numerous (currently 290!) lints to help
improve the correctness, performance and style of your programs. Each lint can
be turned on or off (&lt;code&gt;allow&lt;/code&gt;), and configured as either an error (&lt;code&gt;deny&lt;/code&gt;) or
warning (&lt;code&gt;warn&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;An example: the &lt;a href=&quot;https://rust-lang.github.io/rust-clippy/master/index.html#iter_next_loop&quot;&gt;&lt;code&gt;iter_next_loop&lt;/code&gt;&lt;/a&gt;
lint checks that you haven't made an error by iterating on the result of &lt;code&gt;next&lt;/code&gt;
rather than the object you're calling &lt;code&gt;next&lt;/code&gt; on (this is an easy mistake to make
when changing a &lt;code&gt;while let&lt;/code&gt; loop to a &lt;code&gt;for&lt;/code&gt; loop).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;for x in y.next() {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will give the error&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: you are iterating over `Iterator::next()` which is an Option; this will compile but is probably not what you want
 --&amp;gt; src/main.rs:4:14
  |
4 |     for x in y.next() {
  |              ^^^^^^^^
  |
  = note: #[deny(clippy::iter_next_loop)] on by default
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#iter_next_loop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Clippy works by extending the Rust compiler. The compiler has support for a few
built-in lints, Clippy uses the same mechanisms but with lots more lints. That
means Clippy's error/warning format should be familiar, you should be able to
apply Clippy's suggestions in your IDE (or using Rustfix), and that the lints
are reliable and accurate.&lt;/p&gt;
&lt;p&gt;With Rust 1.31 and the 2018 edition, Clippy is available on stable Rust and has
backwards compatibility guarantees (if it had a version number, it would be
1.0). Clippy has the same stability guarantees as rustc: new lints may be added,
and lints may be modified to add more functionality, however lints may never be
removed (only deprecated). This means that code that compiles with Clippy will
continue to compile with Clippy (provided there are no lints set to error via
&lt;code&gt;deny&lt;/code&gt;), but may throw new warnings.&lt;/p&gt;
&lt;p&gt;Clippy can be installed using &lt;code&gt;rustup component add clippy&lt;/code&gt;, then use it with
&lt;code&gt;cargo clippy&lt;/code&gt;. For more information, including how to run it in your CI, see
&lt;a href=&quot;https://github.com/rust-lang/rust-clippy/&quot;&gt;the repo readme&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thank you Clippy team (Pascal Hertleif (killercup), Oliver Scherer (oli-obk),
Manish Goregaokar (manishearth), and Andre Bogus (llogiq))!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#rustfmt&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rustfmt&quot;&gt;&lt;/a&gt;Rustfmt&lt;/h2&gt;
&lt;p&gt;Rustfmt is a tool for formatting your source code. It takes arbitrary, messy
code and turns it into neat, beautifully styled code.&lt;/p&gt;
&lt;p&gt;Automatically formatting saves you time and mental energy. You don't need to
worry about style as you code. If you use Rustfmt in your CI (&lt;code&gt;cargo fmt --check&lt;/code&gt;), then you don't need to worry about code style in review. By using a
standard style you make your project feel more familiar for new contributors and
spare yourself arguments about code style. Rust's &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/style-guide/README.md&quot;&gt;standard code
style&lt;/a&gt; is
the Rustfmt default, but if you must, then you can customize Rustfmt
extensively.&lt;/p&gt;
&lt;p&gt;Rustfmt 1.0 is part of the 2018 edition release. It should work on all code and
will be backwards compatible until the 2.0 release. By backwards compatible we
mean that if your code is formatted (i.e., excluding bugs which prevent any
formatting or code which does not compile), it will always be formatted in the
same way. This guarantee only applies if you use the default formatting options.&lt;/p&gt;
&lt;p&gt;Rustfmt is not done. Formatting is not perfect, in particular we don't touch
comments and string literals and we are pretty limited with macro definitions
and some macro uses. We're likely to improve formatting here, but you will need
to opt-in to these changes until there is a 2.0 release. We &lt;em&gt;are&lt;/em&gt; planning on
having a 2.0 release. Unlike Rust itself, we think its a good idea to have a
breaking release of Rustfmt and expect that to happen some time in late 2019.&lt;/p&gt;
&lt;p&gt;To install Rustfmt, use &lt;code&gt;rustup component add rustfmt&lt;/code&gt;. To format your project,
use &lt;code&gt;cargo fmt&lt;/code&gt;. You can also format individual files using &lt;code&gt;rustfmt&lt;/code&gt; (though
note that by default rustfmt will format nested modules). You can also use
Rustfmt in your editor or IDE using the RLS (see below; no need to install
rustfmt for this, it comes as part of the RLS). We recommend configuring your
editor to run rustfmt on save. Not having to think about formatting at all as
you type is a pleasant change.&lt;/p&gt;
&lt;p&gt;Thank you Seiichi Uchida (topecongiro), Marcus Klaas, and all the Rustfmt
contributors!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#ide-support&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;ide-support&quot;&gt;&lt;/a&gt;IDE support&lt;/h2&gt;
&lt;p&gt;For many users, their IDE is the most important tool. Rust IDE support has been
in the works for a while and is a highly demanded feature. Rust is now supported
in many IDEs and editors:
&lt;a href=&quot;https://plugins.jetbrains.com/plugin/8182-rust&quot;&gt;IntelliJ&lt;/a&gt;, &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;Visual Studio
Code&lt;/a&gt;,
&lt;a href=&quot;https://github.com/rust-lang-nursery/atom-ide-rust&quot;&gt;Atom&lt;/a&gt;, &lt;a href=&quot;https://github.com/rust-lang/rust-enhanced&quot;&gt;Sublime
Text&lt;/a&gt;,
&lt;a href=&quot;https://www.eclipse.org/downloads/packages/release/photon/r/eclipse-ide-rust-developers-includes-incubating-components&quot;&gt;Eclipse&lt;/a&gt;
(and more...). Follow each link for installation instructions.&lt;/p&gt;
&lt;p&gt;Editor support is powered in two different ways: IntelliJ uses its own compiler,
the other editors use the Rust compiler via the Rust Language Server (RLS). Both
approaches give a good but imperfect IDE experience. You should probably choose
based on which editor you prefer (although if your project does not use Cargo,
then you won't be able to use the RLS).&lt;/p&gt;
&lt;p&gt;All these editors come with support for standard IDE functions including 'go to
definition', 'find all references', code completion, renaming, and reformatting.&lt;/p&gt;
&lt;p&gt;The RLS has been developed by the Rust dev tools team, it is a bid to bring Rust
support to as many IDEs and editors as possible. It directly uses Cargo and the
Rust compiler to provide accurate information about a program. Due to
performance constraints, code completion is not yet powered by the compiler and
therefore can be a bit more hit and miss than other features.&lt;/p&gt;
&lt;p&gt;Thanks to the IDEs and editors team for work on the RLS and the various IDEs and
extensions (alexheretic, autozimu, jasonwilliams, LucasBullen, matklad,
vlad20012, Xanewok), Jonathan Turner for helping start off the RLS, and
phildawes, kngwyu, jwilm, and the other Racer contributors for their work on
Racer (the code completion component of the RLS)!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#the-future&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-future&quot;&gt;&lt;/a&gt;The future&lt;/h2&gt;
&lt;p&gt;We're not done yet! There's lots more we think we can do in the tools domain
over the next year or so.&lt;/p&gt;
&lt;p&gt;We've been improving rust debugging support in LLDB and GDB and there is more in
the works. We're experimenting with distributing our own versions with Rustup
and making debugging from your IDE easier and more powerful.&lt;/p&gt;
&lt;p&gt;We hope to make the RLS faster, more stable, and more accurate; including using
the compiler for code completion.&lt;/p&gt;
&lt;p&gt;We want to make Cargo a lot more powerful: Cargo will handle compiled binaries
as well as source code, which will make building and installing crates faster.
We will support better integration with other build systems (which in turn will
enable using the RLS with more projects). We'll add commands for adding and
upgrading dependencies, and to help with security audits.&lt;/p&gt;
&lt;p&gt;Rustdoc will see improvements to its source view (powered by the RLS) and links
between documentation for different crates.&lt;/p&gt;
&lt;p&gt;There's always lots of interesting things to work on. If you'd like to help chat
to us on GitHub or &lt;a href=&quot;https://discordapp.com/invite/rust-lang&quot;&gt;Discord&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Dev-tools team</name>
        </author>
    </entry>
    
    <entry>
        <title>A call for Rust 2019 Roadmap blog posts</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html" type="text/html" title="A call for Rust 2019 Roadmap blog posts" />
        <published>2018-12-06T00:00:00Z</published>
        <updated>2018-12-06T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html">&lt;p&gt;It's almost 2019! As such, the Rust team needs to create a roadmap for Rust's
development next year. At the highest level, Rust's development process looks
like this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The Rust community blogs about what they'd like to see.&lt;/li&gt;
&lt;li&gt;The core team reads these posts, and produces a &amp;quot;roadmap RFC,&amp;quot; a proposal
for what next year's development looks like.&lt;/li&gt;
&lt;li&gt;The RFC is widely discussed, and modified in response to feedback, and
eventually accepted.&lt;/li&gt;
&lt;li&gt;This RFC becomes a guideline for accepting or postponing RFCs for the next
year.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We try to align this with the calendar year, but it doesn't 100% match up,
currently. Last year, &lt;a href=&quot;https://blog.rust-lang.org/2018/01/03/new-years-rust-a-call-for-community-blogposts.html&quot;&gt;we had a call for posts on January
3&lt;/a&gt;,
the roadmap RFC was opened &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2314&quot;&gt;on Jan
29th&lt;/a&gt;, and was &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2314#issuecomment-370576889&quot;&gt;accepted on
March
5th&lt;/a&gt;.
This year, we're starting a bit earlier, but it's still not going to be
accepted before January 1.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#we-need-you&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;we-need-you&quot;&gt;&lt;/a&gt;We need you&lt;/h2&gt;
&lt;p&gt;Starting today and running until of January 15, we’d like to ask the
community to write blogposts reflecting on Rust in 2018 and proposing goals
and directions for Rust in 2019. Like last year, these can take many forms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A post on your personal or company blog&lt;/li&gt;
&lt;li&gt;A Medium post&lt;/li&gt;
&lt;li&gt;A GitHub gist&lt;/li&gt;
&lt;li&gt;Or any other online writing platform you prefer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We’re looking for posts on many topics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ideas for community programs&lt;/li&gt;
&lt;li&gt;Language features&lt;/li&gt;
&lt;li&gt;Documentation improvements&lt;/li&gt;
&lt;li&gt;Ecosystem needs&lt;/li&gt;
&lt;li&gt;Tooling enhancements&lt;/li&gt;
&lt;li&gt;Or anything else Rust related you hope for in 2019&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There's one additional thing this year, however. With the shipping of Rust
2018 today, it's time to think about the next edition. In other words:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rust 2015: Stability&lt;/li&gt;
&lt;li&gt;Rust 2018: Productivity&lt;/li&gt;
&lt;li&gt;Rust 2021: ?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We aren't yet &lt;em&gt;committing&lt;/em&gt; to an edition in 2021, but that's the current
estimate. Each edition has had some sort of theme associated with it. As
such, we wouldn't just like to know what you're thinking for Rust in 2019,
but also, what you want the theme of Rust 2021 to be. Ideally, suggestions
for Rust in 2019 will fit into the overall goal of the next edition, though
of course, three years is a lot of time, and so not every single thing must.
As Rust matures, we need to start thinking of ever-longer horizons, and how
our current plans fit into those eventual plans.&lt;/p&gt;
&lt;p&gt;If you're not sure what to write, check out all of the blog posts from last
year &lt;a href=&quot;https://readrust.net/rust-2018/&quot;&gt;over at ReadRust&lt;/a&gt;. They may give you
some inspiration!&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#please-share-these-posts-with-us&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;please-share-these-posts-with-us&quot;&gt;&lt;/a&gt;Please share these posts with us&lt;/h2&gt;
&lt;p&gt;You can write up these posts and email them to &lt;code&gt;community@rust-lang.org&lt;/code&gt; or
tweet them with the hashtag &lt;code&gt;#rust2019&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The Core team will be reading all of the submitted posts and using them to
inform the initial roadmap RFC for 2019. Once the RFC is submitted, we’ll
open up the normal RFC process, though if you want, you are welcome to write
a post and link to it on the GitHub discussion.&lt;/p&gt;
&lt;p&gt;We look forward to working with the entire community to make Rust even more
wonderful in 2019. Thanks for an awesome 2018!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.31 and Rust 2018</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html" type="text/html" title="Announcing Rust 1.31 and Rust 2018" />
        <published>2018-12-06T00:00:00Z</published>
        <updated>2018-12-06T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.31.0, and &amp;quot;Rust
2018&amp;quot; as well. Rust is a programming language that empowers everyone to build
reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.31.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/tools/install&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06&quot;&gt;detailed release notes for
1.31.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.31.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.31.0-stable&quot;&gt;&lt;/a&gt;What's in 1.31.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.31 may be the most exciting release since Rust 1.0! Included in this release is the
first iteration of &amp;quot;Rust 2018,&amp;quot; but there's more than just that! This is going to be a long
post, so here's a table of contents:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#rust-2018&quot;&gt;Rust 2018&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#non-lexical-lifetimes&quot;&gt;Non-lexical lifetimes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#module-system-changes&quot;&gt;Module system changes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#more-lifetime-elision-rules&quot;&gt;More lifetime elision rules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#const-fn&quot;&gt;&lt;code&gt;const fn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#new-tools&quot;&gt;New tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#tool-lints&quot;&gt;Tool Lints&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#documentation&quot;&gt;Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#domain-working-groups&quot;&gt;Domain working groups&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#new-website&quot;&gt;New website&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#library-stabilizations&quot;&gt;Library stabilizations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#cargo-features&quot;&gt;Cargo features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#contributors-to-131.0&quot;&gt;Contributors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#rust-2018&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;rust-2018&quot;&gt;&lt;/a&gt;Rust 2018&lt;/h3&gt;
&lt;p&gt;We wrote about Rust 2018 &lt;a href=&quot;https://blog.rust-lang.org/2018/03/12/roadmap.html&quot;&gt;first in
March&lt;/a&gt;, &lt;a href=&quot;https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html&quot;&gt;and then in
July&lt;/a&gt;.
For some more background about the &lt;em&gt;why&lt;/em&gt; of Rust 2018, please go read those
posts; there's a lot to cover in the release announcement, and so we're going
to focus on the &lt;em&gt;what&lt;/em&gt; here. There's also a &lt;a href=&quot;https://hacks.mozilla.org/2018/12/rust-2018-is-here/&quot;&gt;post on Mozilla Hacks&lt;/a&gt; as
well!&lt;/p&gt;
&lt;p&gt;Briefly, Rust 2018 is an opportunity to bring
all of the work we've been doing over the past three years together, and create
a cohesive package. This is more than just language features, it also includes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tooling (IDE support, &lt;code&gt;rustfmt&lt;/code&gt;, Clippy)&lt;/li&gt;
&lt;li&gt;Documentation&lt;/li&gt;
&lt;li&gt;Domain working groups work&lt;/li&gt;
&lt;li&gt;A new web site&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll be covering all of this and more in this post.&lt;/p&gt;
&lt;p&gt;Let's create a new project with Cargo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ cargo new foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here's the contents of &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[package]
name = &amp;quot;foo&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Your Name &amp;lt;you@example.com&amp;gt;&amp;quot;]
edition = &amp;quot;2018&amp;quot;

[dependencies]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A new key has been added under &lt;code&gt;[package]&lt;/code&gt;: &lt;code&gt;edition&lt;/code&gt;. Note that it has been
set to &lt;code&gt;2018&lt;/code&gt;. You can also set it to &lt;code&gt;2015&lt;/code&gt;, which is the default if the key
does not exist.&lt;/p&gt;
&lt;p&gt;By using Rust 2018, some new features are unlocked that are not allowed in
Rust 2015.&lt;/p&gt;
&lt;p&gt;It is important to note that each package can be in either 2015 or
2018 mode, and they work seamlessly together. Your 2018 project can use 2015
dependencies, and a 2015 project can use 2018 dependencies. This ensures that
we don't split the ecosystem, and all of these new things are opt-in,
preserving compatibility for existing code. Furthermore, when you do choose
to migrate Rust 2015 code to Rust 2018, the changes can be made
automatically, via &lt;code&gt;cargo fix&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What kind of new features, you may ask? Well, first, features get added to
Rust 2015 unless they require some sort of incompatibility with 2015's
features. As such, most of the language is available everywhere. You can
check out &lt;a href=&quot;https://doc.rust-lang.org/edition-guide&quot;&gt;the edition
guide&lt;/a&gt; to check each
feature's minimum &lt;code&gt;rustc&lt;/code&gt; version as well as edition requirements. However,
there are a few big-ticket features we'd like to mention here: non-lexical
lifetimes, and some module system improvements.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#non-lexical-lifetimes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;non-lexical-lifetimes&quot;&gt;&lt;/a&gt;Non-lexical lifetimes&lt;/h4&gt;
&lt;p&gt;If you've been following Rust's development over the past few years, you may
have heard the term &amp;quot;NLL&amp;quot; or &amp;quot;non-lexical lifetimes&amp;quot; thrown around. This is
jargon, but it has a straightforward translation into simpler terms: the
borrow checker has gotten smarter, and now accepts some valid code that it
previously rejected. Consider this example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let mut x = 5;

    let y = &amp;amp;x;

    let z = &amp;amp;mut x;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In older Rust, this is a compile-time error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&amp;gt; src/main.rs:5:18
  |
4 |     let y = &amp;amp;x;
  |              - immutable borrow occurs here
5 |     let z = &amp;amp;mut x;
  |                  ^ mutable borrow occurs here
6 | }
  | - immutable borrow ends here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because lifetimes follow &amp;quot;lexical scope&amp;quot;; that is, the borrow from &lt;code&gt;y&lt;/code&gt;
is considered to be held until &lt;code&gt;y&lt;/code&gt; goes out of scope at the end of main, even
though we never use &lt;code&gt;y&lt;/code&gt; again. This code is fine, but the borrow checker could
not handle it.&lt;/p&gt;
&lt;p&gt;Today, this code will compile just fine.&lt;/p&gt;
&lt;p&gt;What if we did use &lt;code&gt;y&lt;/code&gt;, like this for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let mut x = 5;
    let y = &amp;amp;x;
    let z = &amp;amp;mut x;
    
    println!(&amp;quot;y: {}&amp;quot;, y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Older Rust will give you this error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&amp;gt; src/main.rs:5:18
  |
4 |     let y = &amp;amp;x;
  |              - immutable borrow occurs here
5 |     let z = &amp;amp;mut x;
  |                  ^ mutable borrow occurs here
...
8 | }
  | - immutable borrow ends here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With Rust 2018, this error changes for the better:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&amp;gt; src/main.rs:5:13
  |
4 |     let y = &amp;amp;x;
  |             -- immutable borrow occurs here
5 |     let z = &amp;amp;mut x;
  |             ^^^^^^ mutable borrow occurs here
6 |     
7 |     println!(&amp;quot;y: {}&amp;quot;, y);
  |                       - borrow later used here
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of pointing to where &lt;code&gt;y&lt;/code&gt; goes out of scope, it shows you where the
conflicting borrow occurs. This makes these sorts of errors far easier to
debug.&lt;/p&gt;
&lt;p&gt;In Rust 1.31, this feature is exclusive to Rust 2018. We plan to backport it
to Rust 2015 at a later date.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#module-system-changes&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;module-system-changes&quot;&gt;&lt;/a&gt;Module system changes&lt;/h4&gt;
&lt;p&gt;The module system can be a struggle for people first learning Rust.
Everyone has their own things that take time to master, of course, but
there's a root cause for why it's so confusing to many: while there are
simple and consistent rules defining the module system, their consequences
can feel inconsistent, counterintuitive and mysterious.&lt;/p&gt;
&lt;p&gt;As such, the 2018 edition of Rust introduces a few changes to how paths work,
but they end up simplifying the module system, to make it more clear as to
what is going on.&lt;/p&gt;
&lt;p&gt;Here's a brief summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern crate&lt;/code&gt; is no longer needed in almost all circumstances.&lt;/li&gt;
&lt;li&gt;You can import macros with &lt;code&gt;use&lt;/code&gt;, rather than a &lt;code&gt;#[macro_use]&lt;/code&gt; attribute.&lt;/li&gt;
&lt;li&gt;Absolute paths begin with a crate name, where the keyword &lt;code&gt;crate&lt;/code&gt; refers to the current crate.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;foo.rs&lt;/code&gt; and &lt;code&gt;foo/&lt;/code&gt; subdirectory may coexist; &lt;code&gt;mod.rs&lt;/code&gt; is no longer needed when placing submodules in a subdirectory.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These may seem like arbitrary new rules when put this way, but the mental
model is now significantly simplified overall.&lt;/p&gt;
&lt;p&gt;There's a &lt;em&gt;lot&lt;/em&gt; of details here, so please read &lt;a href=&quot;https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html&quot;&gt;the edition
guide&lt;/a&gt;
for full details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#more-lifetime-elision-rules&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;more-lifetime-elision-rules&quot;&gt;&lt;/a&gt;More lifetime elision rules&lt;/h3&gt;
&lt;p&gt;Let's talk about a feature that's available in both editions: we've added
some additional elision rules for &lt;code&gt;impl&lt;/code&gt; blocks and function definitions.
Code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;impl&amp;lt;'a&amp;gt; Reader for BufReader&amp;lt;'a&amp;gt; {
    // methods go here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;can now be written like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;impl Reader for BufReader&amp;lt;'_&amp;gt; {
    // methods go here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;'_&lt;/code&gt; lifetime still shows that &lt;code&gt;BufReader&lt;/code&gt; takes a parameter, but we
don't need to create a name for it anymore.&lt;/p&gt;
&lt;p&gt;Lifetimes are still required to be defined in structs. However, we no longer
require as much boilerplate as before:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;// Rust 2015
struct Ref&amp;lt;'a, T: 'a&amp;gt; {
    field: &amp;amp;'a T
}

// Rust 2018
struct Ref&amp;lt;'a, T&amp;gt; {
    field: &amp;amp;'a T
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;: 'a&lt;/code&gt; is inferred. You can still be explicit if you prefer. We're
considering some more options for elision here in the future, but have no
concrete plans yet.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#const-fn&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;const-fn&quot;&gt;&lt;/a&gt;&lt;code&gt;const fn&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;There's several ways to define a function in Rust: a regular function with
&lt;code&gt;fn&lt;/code&gt;, an unsafe function with &lt;code&gt;unsafe fn&lt;/code&gt;, an external function with &lt;code&gt;extern fn&lt;/code&gt;.
This release adds a new way to qualify a function: &lt;code&gt;const fn&lt;/code&gt;. It looks like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const fn foo(x: i32) -&amp;gt; i32 {
    x + 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;code&gt;const fn&lt;/code&gt; can be called like a regular function, but it can also be used
in any constant context. When it is, it is evaluated at compile time, rather
than at run time. As an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const SIX: i32 = foo(5);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will execute &lt;code&gt;foo&lt;/code&gt; at compile time, and set &lt;code&gt;SIX&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const fn&lt;/code&gt;s cannot do everything that normal &lt;code&gt;fn&lt;/code&gt;s can do; they must
have deterministic output. This is important for soundness reasons.
Currently, &lt;code&gt;const fn&lt;/code&gt;s can do a minimal subset of operations. Here's
some examples of what you can do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arithmetic and comparison operators on integers&lt;/li&gt;
&lt;li&gt;All boolean operators except for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Constructing arrays, structs, enums, and tuples&lt;/li&gt;
&lt;li&gt;Calls to other &lt;code&gt;const fn&lt;/code&gt;s&lt;/li&gt;
&lt;li&gt;Index expressions on arrays and slices&lt;/li&gt;
&lt;li&gt;Field accesses on structs and tuples&lt;/li&gt;
&lt;li&gt;Reading from constants (but not statics, not even taking a reference to a static)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; of references&lt;/li&gt;
&lt;li&gt;Casts, except for raw pointer to integer casts&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll be growing the abilities of &lt;code&gt;const fn&lt;/code&gt;, but we've decided that
this is enough useful stuff to start shipping the feature itself.&lt;/p&gt;
&lt;p&gt;For full details, please see &lt;a href=&quot;https://doc.rust-lang.org/reference/items/functions.html#const-functions&quot;&gt;the
reference&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#new-tools&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;new-tools&quot;&gt;&lt;/a&gt;New tools&lt;/h3&gt;
&lt;p&gt;The 2018 edition signals a new level of maturity for Rust's tools ecosystem.
Cargo, Rustdoc, and Rustup have been crucial tools since 1.0; with the 2018
edition, there is a new generation of tools ready for all users: Clippy,
Rustfmt, and IDE support.&lt;/p&gt;
&lt;p&gt;Rust's linter, &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/&quot;&gt;&lt;code&gt;clippy&lt;/code&gt;&lt;/a&gt;, is
now available on stable Rust. You can install it via &lt;code&gt;rustup component add clippy&lt;/code&gt; and run it with &lt;code&gt;cargo clippy&lt;/code&gt;. Clippy is now considered 1.0, which
carries the same lint stability guarantees as rustc. New lints may be added,
and lints may be modified to add more functionality, however lints may never
be removed (only deprecated). This means that code that compiles under clippy
will continue to compile under clippy (provided there are no lints set to
error via &lt;code&gt;deny&lt;/code&gt;), but may throw new warnings.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rustfmt&quot;&gt;Rustfmt&lt;/a&gt; is a tool for formatting Rust
code. Automatically formatting your code lets you save time and arguments by
using the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/style-guide/README.md&quot;&gt;official Rust
style&lt;/a&gt;.
You can install with &lt;code&gt;rustup component add rustfmt&lt;/code&gt; and use it with &lt;code&gt;cargo fmt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This release includes Rustfmt 1.0. From now on we guarantee backwards
compatibility for Rustfmt: if you can format your code today, then the
formatting will not change in the future (only with the default options).
Backwards compatibility means that running Rustfmt on your CI is practical
(use &lt;code&gt;cargo fmt -- --check&lt;/code&gt;). Try that and 'format on save' in your editor to
revolutionize your workflow.&lt;/p&gt;
&lt;p&gt;IDE support is one of the most requested tooling features for Rust. There are
now multiple, high quality options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust&quot;&gt;Visual Studio Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://plugins.jetbrains.com/plugin/8182-rust&quot;&gt;IntelliJ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang-nursery/atom-ide-rust&quot;&gt;Atom&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust-enhanced&quot;&gt;Sublime Text 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.eclipse.org/downloads/packages/release/photon/r/eclipse-ide-rust-developers-includes-incubating-components&quot;&gt;Eclipse&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Work on IDE support is not finished, in particular code completion is not up
to scratch in the RLS-based editors. However, if you mainly want support for
types, documentation, and 'go to def', etc. then you should be happy.&lt;/p&gt;
&lt;p&gt;If you have problems installing any of the tools with Rustup, try running
&lt;code&gt;rustup self update&lt;/code&gt;, and then try again.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#tool-lints&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;tool-lints&quot;&gt;&lt;/a&gt;Tool lints&lt;/h3&gt;
&lt;p&gt;In &lt;a href=&quot;https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html&quot;&gt;Rust 1.30&lt;/a&gt;, we
stabilized &amp;quot;tool attributes&amp;quot;, like &lt;code&gt;#[rustfmt::skip]&lt;/code&gt;. In Rust 1.31, we're
stabilizing something similar: &amp;quot;tool lints,&amp;quot; like
&lt;code&gt;#[allow(clippy::bool_comparison)]&lt;/code&gt; These give a namespace to lints, so that it's
more clear which tool they're coming from.&lt;/p&gt;
&lt;p&gt;If you previously used Clippy's lints, you can migrate like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;// old
#![cfg_attr(feature = &amp;quot;cargo-clippy&amp;quot;, allow(bool_comparison))]

// new
#![allow(clippy::bool_comparison)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You don't need &lt;code&gt;cfg_attr&lt;/code&gt; anymore! You'll also get warnings that can help you
update to the new style.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#documentation&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;documentation&quot;&gt;&lt;/a&gt;Documentation&lt;/h3&gt;
&lt;p&gt;Rustdoc has seen a number of improvements this year, and we also shipped a
complete re-write of the &amp;quot;The Rust Programming Language.&amp;quot; Additionally, you
can &lt;a href=&quot;https://nostarch.com/rust&quot;&gt;buy a dead-tree copy from No Starch Press&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;We had previously called this the &amp;quot;second edition&amp;quot; of the book, but since
it's the first edition in print, that was confusing. We also want to
periodically update the print edition as well. In the end, after many
discussions with No Starch, we're going to be updating the book on the
website with each release, and No Starch will periodically pull in our
changes and print them. The book has been selling quite well so far, raising
money for &lt;a href=&quot;http://www.blackgirlscode.com/&quot;&gt;Black Girls Code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can find the new TRPL &lt;a href=&quot;https://doc.rust-lang.org/beta/book/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#domain-working-groups&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;domain-working-groups&quot;&gt;&lt;/a&gt;Domain working groups&lt;/h3&gt;
&lt;p&gt;We announced the formation of four working groups this year:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network services&lt;/li&gt;
&lt;li&gt;Command-line applications&lt;/li&gt;
&lt;li&gt;WebAssembly&lt;/li&gt;
&lt;li&gt;Embedded devices&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each of these groups has been working very hard on a number of things to
make Rust awesome in each of these domains. Some highlights:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network services has been shaking out the Futures interface, and async/await
on top of it. This hasn't shipped yet, but we're close!&lt;/li&gt;
&lt;li&gt;The CLI working group has been working on libraries and documentation for making awesome
command-line applications&lt;/li&gt;
&lt;li&gt;The WebAssembly group has been shipping a ton of world-class tooling for using Rust with wasm.&lt;/li&gt;
&lt;li&gt;Embedded devices has gotten ARM development working on stable Rust!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find out more about this work on the new website!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#new-website&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;new-website&quot;&gt;&lt;/a&gt;New Website&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html&quot;&gt;Last
week&lt;/a&gt;
we announced a new iteration of the web site. It's now been promoted to
rust-lang.org itself!&lt;/p&gt;
&lt;p&gt;There's still a ton of work to do, but we're proud of the year of work that it
took by many people to get it shipped.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;A bunch of &lt;code&gt;From&lt;/code&gt; implementations have been added:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;u8&lt;/code&gt; now implements &lt;code&gt;From&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt;, and likewise for the other numeric types and their &lt;code&gt;NonZero&lt;/code&gt; equivalents&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; implements &lt;code&gt;From&amp;lt;&amp;amp;Option&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, and likewise for &lt;code&gt;&amp;amp;mut&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, these functions have been stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.align_to&quot;&gt;&lt;code&gt;slice::align_to&lt;/code&gt;&lt;/a&gt; and its mutable counterpart&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact&quot;&gt;&lt;code&gt;slice::chunks_exact&lt;/code&gt;&lt;/a&gt;,
as well as its mutable and &lt;code&gt;r&lt;/code&gt; counterparts (like
&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_mut&quot;&gt;&lt;code&gt;slice::rchunks_exact_mut&lt;/code&gt;&lt;/a&gt;) in all combinations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cargo-features&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cargo-features&quot;&gt;&lt;/a&gt;Cargo features&lt;/h3&gt;
&lt;p&gt;Cargo will now download packages in parallel using HTTP/2.&lt;/p&gt;
&lt;p&gt;Additionally, now that &lt;code&gt;extern crate&lt;/code&gt; is not usually required, it would be
jarring to do &lt;code&gt;extern crate foo as baz;&lt;/code&gt; to rename a crate. As such, you can
do so in your &lt;code&gt;Cargo.toml&lt;/code&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies]
baz = { version = &amp;quot;0.1&amp;quot;, package = &amp;quot;foo&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or, the equivalent&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies.baz]
version = &amp;quot;0.1&amp;quot;
package = &amp;quot;foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, the &lt;code&gt;foo&lt;/code&gt; package will be able to be used via &lt;code&gt;baz&lt;/code&gt; in your code.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1310-2018-12-06&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-131.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-131.0&quot;&gt;&lt;/a&gt;Contributors to 1.31.0&lt;/h2&gt;
&lt;p&gt;At the end of release posts, we normally thank &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.31.0&quot;&gt;the people who contributed to
this release&lt;/a&gt;. But for this
release, more so than others, this list does not truly capture the amount of
work and the number of people who have contributed. Each release is only six
weeks, but this release is the culmination of three years of effort, in
countless repositories, by numerous people. It's been a pleasure to work with
you all, and we look forward to continuing to grow in the next three years.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
</feed>