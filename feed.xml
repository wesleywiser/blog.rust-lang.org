<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Team.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2019-05-14T11:41:31Z</updated>

    
    <entry>
        <title>Security advisory for the standard library</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/05/13/Security-advisory.html" type="text/html" title="Security advisory for the standard library" />
        <published>2019-05-13T00:00:00Z</published>
        <updated>2019-05-13T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/05/13/Security-advisory.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/05/13/Security-advisory.html">&lt;p&gt;This is a cross-post of the &lt;a href=&quot;https://groups.google.com/forum/#!topic/rustlang-security-announcements/aZabeCMUv70&quot;&gt;official security advisory&lt;/a&gt;. The
official post contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;p&gt;The CVE for this vulnerability is &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-0803&quot;&gt;CVE-2019-12083&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The Rust team was recently notified of a security vulnerability affecting
manual implementations of &lt;code&gt;Error::type_id&lt;/code&gt; and their interaction with the
&lt;code&gt;Error::downcast&lt;/code&gt; family of functions in the standard library. If your code
does not manually implement &lt;code&gt;Error::type_id&lt;/code&gt; your code is not affected.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#overview&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Error::type_id&lt;/code&gt; function in the standard library was stabilized in the
1.34.0 release on 2019-04-11. This function allows acquiring the concrete
&lt;code&gt;TypeId&lt;/code&gt; for the underlying error type to downcast back to the original type.
This function has a default implementation in the standard library, but it can
also be overridden by downstream crates. For example, the following is
currently allowed on Rust 1.34.0 and Rust 1.34.1:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;struct MyType;

impl Error for MyType {
    fn type_id(&amp;amp;self) -&amp;gt; TypeId {
        // Enable safe casting to `String` by accident.
        TypeId::of::&amp;lt;String&amp;gt;()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When combined with the &lt;code&gt;Error::downcast*&lt;/code&gt; family of methods this can enable
safe casting of a type to the wrong type, causing security issues such as out
of bounds reads/writes/etc.&lt;/p&gt;
&lt;p&gt;Prior to the 1.34.0 release this function was not stable and could not be
either implemented or called in stable Rust.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#affected-versions&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected Versions&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Error::type_id&lt;/code&gt; function was first stabilized in Rust 1.34.0, released on
2019-04-11. The Rust 1.34.1 release, published 2019-04-25, is also affected.
The &lt;code&gt;Error::type_id&lt;/code&gt; function has been present, unstable, for all releases of
Rust since 1.0.0 meaning code compiled with nightly may have been affected at
any time.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#mitigations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;Immediate mitigation of this bug requires removing manual implementations of
&lt;code&gt;Error::type_id&lt;/code&gt;, instead inheriting the default implementation which is
correct from a safety perspective. It is not the intention to have
&lt;code&gt;Error::type_id&lt;/code&gt; return &lt;code&gt;TypeId&lt;/code&gt; instances for other types.&lt;/p&gt;
&lt;p&gt;For long term mitigation we are going to destabilize this function. This is
unfortunately a breaking change for users calling &lt;code&gt;Error::type_id&lt;/code&gt; and for
users overriding &lt;code&gt;Error::type_id&lt;/code&gt;. For users overriding it's likely memory
unsafe, but users calling &lt;code&gt;Error::type_id&lt;/code&gt; have only been able to do so on
stable for a few weeks since the last 1.34.0 release, so it's thought that the
impact will not be too great to overcome.&lt;/p&gt;
&lt;p&gt;We will be releasing a 1.34.2 point release on 2019-05-14 (tomorrow) which
reverts &lt;a href=&quot;https://github.com/rust-lang/rust/pull/58048&quot;&gt;#58048&lt;/a&gt; and destabilizes the &lt;code&gt;Error::type_id&lt;/code&gt; function. The
upcoming 1.35.0 release along with the beta/nightly channels will also all be
updated with a destabilization.&lt;/p&gt;
&lt;p&gt;The final fate of the &lt;code&gt;Error::type_id&lt;/code&gt; API isn't decided upon just yet and is
the subject of &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60784&quot;&gt;#60784&lt;/a&gt;. No action beyond destabilization is currently
planned so nightly code may continue to exhibit this issue. We hope to fully
resolve this in the standard library soon.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#timeline-of-events&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;timeline-of-events&quot;&gt;&lt;/a&gt;Timeline of events&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Thu, May  9, 2019 at 14:07 PM - Bug reported to security@rust-lang.org&lt;/li&gt;
&lt;li&gt;Thu, May  9, 2019 at 15:10 PM - Alex reponds, confirming the bug&lt;/li&gt;
&lt;li&gt;Fri, May 10, 2019 - Plan for mitigation developed and implemented&lt;/li&gt;
&lt;li&gt;Mon, May 13, 2019 - PRs posted to GitHub for &lt;a href=&quot;https://github.com/rust-lang/rust/pull/60785&quot;&gt;stable&lt;/a&gt;/&lt;a href=&quot;https://github.com/rust-lang/rust/pull/60786&quot;&gt;beta&lt;/a&gt;/&lt;a href=&quot;https://github.com/rust-lang/rust/pull/60787&quot;&gt;master&lt;/a&gt; branches&lt;/li&gt;
&lt;li&gt;Mon, May 13, 2019 - Security list informed of this issue&lt;/li&gt;
&lt;li&gt;(planned) Tue, May 14, 2019 - Rust 1.34.2 is released with a fix for this issue&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#acknowledgements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;acknowledgements&quot;&gt;&lt;/a&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thanks to Sean McArthur, who found this bug and reported it to us in accordance
with our &lt;a href=&quot;https://www.rust-lang.org/policies/security&quot;&gt;security policy&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Mozilla IRC Sunset and the Rust Channel</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/26/Mozilla-IRC-Sunset-and-the-Rust-Channel.html" type="text/html" title="Mozilla IRC Sunset and the Rust Channel" />
        <published>2019-04-26T00:00:00Z</published>
        <updated>2019-04-26T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/26/Mozilla-IRC-Sunset-and-the-Rust-Channel.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/26/Mozilla-IRC-Sunset-and-the-Rust-Channel.html">&lt;p&gt;The Rust community has had a presence on Mozilla‚Äôs IRC network almost since Rust‚Äôs inception. Over time, the single channel grew into a set of pretty active channels where folks would come to ask Rust questions, coordinate work on Rust itself, and just in general chat about Rust.&lt;/p&gt;
&lt;p&gt;Mozilla &lt;a href=&quot;http://exple.tive.org/blarg/2019/04/26/synchronous-text/&quot;&gt;recently announced&lt;/a&gt; that it would be shutting down its IRC network, citing a growing maintenance and moderation burden. They are looking into new options for the Mozilla community, but this does leave the question open as to what the Rust project will do.&lt;/p&gt;
&lt;p&gt;Last year a lot of the teams &lt;a href=&quot;https://internals.rust-lang.org/t/exploring-new-communication-channels/7859&quot;&gt;started exploring new communication platforms&lt;/a&gt;. Almost all the Rust teams no longer use IRC as their official discussion platform, instead using Discord or Zulip (as well as a variety of video chat tools for synchronous meetings). The few teams that do use IRC are working with us to find a new home, likely a channel on Discord or Zulip.&lt;/p&gt;
&lt;p&gt;This leaves the #rust and #rust-beginners channels on Mozilla‚Äôs IRC network, which are still quite active, that will need a new home when Mozilla‚Äôs network shuts down. Rust‚Äôs &lt;a href=&quot;http://discord.gg/rust-lang&quot;&gt;official Discord server&lt;/a&gt; does have the #users, #help, and #beginners channels that fill in this purpose, and we recommend people start using those.&lt;/p&gt;
&lt;p&gt;We understand that not everyone wishes to switch to Discord for many reasons. For people who wish to continue using IRC, there is &lt;a href=&quot;http://webchat.freenode.net/?channels=##rust&quot;&gt;an unofficial freenode channel&lt;/a&gt; which you can hang out in, though we‚Äôd like to emphasize that this is not associated with the Rust teams and is not moderated by our Moderation team. You‚Äôre also free to create new channels on freenode &lt;a href=&quot;https://freenode.net/policies#off-topic-use&quot;&gt;in accordance with the freenode rules&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are still a couple months before irc.mozilla.org shuts down ‚Äî we‚Äôll work at making this transition as smooth as possible in this time. Thanks to everyone who made #rust and #rust-beginners on Mozilla IRC a great place to hang out! We are sad to see it go. üò¢&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.34.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html" type="text/html" title="Announcing Rust 1.34.1" />
        <published>2019-04-25T00:00:00Z</published>
        <updated>2019-04-25T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.34.1, and a new version of rustup, 1.18.1.
Rust is a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup,
getting Rust 1.34.1 and rustup 1.18.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.34.1-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.34.1-stable&quot;&gt;&lt;/a&gt;What's in 1.34.1 stable&lt;/h2&gt;
&lt;p&gt;This patch release fixes two false positives and &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/pull/3805&quot;&gt;a panic when checking macros&lt;/a&gt; in &lt;a href=&quot;https://github.com/rust-lang/rust-clippy&quot;&gt;Clippy&lt;/a&gt;.
Clippy is a tool which provides a collection of lints to catch common mistakes and improve your Rust code.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#false-positive-in-clippy:redundant_closure&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;false-positive-in-clippy:redundant_closure&quot;&gt;&lt;/a&gt;False positive in &lt;code&gt;clippy::redundant_closure&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;A false positive in the &lt;code&gt;redundant_closure&lt;/code&gt; lint was &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/pull/3821&quot;&gt;fixed&lt;/a&gt;.
The lint did not take into account &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/issues/3802&quot;&gt;differences in the number of borrows&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the following snippet, the method &lt;code&gt;required&lt;/code&gt; expects &lt;code&gt;dep: &amp;amp;D&lt;/code&gt; but the actual type of &lt;code&gt;dep&lt;/code&gt; is &lt;code&gt;&amp;amp;&amp;amp;D&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;dependencies.iter().filter(|dep| dep.required());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Clippy erronously suggested &lt;code&gt;.filter(Dependency::required)&lt;/code&gt;,
which is rejected by the compiler due to the difference in borrows.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#false-positive-in-clippy:missing_const_for_fn&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;false-positive-in-clippy:missing_const_for_fn&quot;&gt;&lt;/a&gt;False positive in &lt;code&gt;clippy::missing_const_for_fn&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Another false positive in the &lt;code&gt;missing_const_for_fn&lt;/code&gt; lint was &lt;a href=&quot;https://github.com/rust-lang/rust-clippy/pull/3844&quot;&gt;fixed&lt;/a&gt;.
This lint did not take into account that functions inside &lt;code&gt;trait&lt;/code&gt; implementations cannot be &lt;code&gt;const fn&lt;/code&gt;s.
For example, when given the following snippet, the lint would trigger:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[derive(PartialEq, Eq)] // warning: this could be a const_fn
struct Point(isize, isize);

impl std::ops::Add for Point {
    type Output = Self;

    fn add(self, other: Self) -&amp;gt; Self { // warning: this could be a const_fn
        Point(self.0 + other.0, self.1 + other.1)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-new-in-rustup-1.18.1&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-new-in-rustup-1.18.1&quot;&gt;&lt;/a&gt;What's new in rustup 1.18.1&lt;/h2&gt;
&lt;p&gt;A recent rustup release, 1.18.0, introduced &lt;a href=&quot;https://github.com/rust-lang/rustup.rs/issues/1794&quot;&gt;a regression&lt;/a&gt; that prevented installing Rust through the shell script on older platforms.
A patch was released that fixes the issue, avoiding to force TLS v1.2 on the platforms that don't support it.&lt;/p&gt;
&lt;p&gt;You can check out other rustup changes in its &lt;a href=&quot;https://github.com/rust-lang/rustup.rs/blob/master/CHANGELOG.md#1181---2019-04-25&quot;&gt;full release notes&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust's 2019 roadmap</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/23/roadmap.html" type="text/html" title="Rust's 2019 roadmap" />
        <published>2019-04-23T00:00:00Z</published>
        <updated>2019-04-23T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/23/roadmap.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/23/roadmap.html">&lt;p&gt;Each year the Rust community &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1728&quot;&gt;comes together&lt;/a&gt; to set out a
roadmap. This year, in addition to the &lt;a href=&quot;https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html&quot;&gt;survey&lt;/a&gt;, we put out a &lt;a href=&quot;https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html&quot;&gt;call for blog
posts&lt;/a&gt; in December, which resulted in &lt;a href=&quot;https://readrust.net/rust-2019/&quot;&gt;73 blog posts&lt;/a&gt;
written over the span of a few weeks. The end result is the recently-merged
&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md&quot;&gt;2019 roadmap RFC&lt;/a&gt;. To get all of the details, please give it a read,
but this post lays out some of the highlights.&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#the-theme-maturity&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-theme-maturity&quot;&gt;&lt;/a&gt;The theme: Maturity&lt;/h1&gt;
&lt;p&gt;In short, 2019 will be a year of &lt;em&gt;rejuvenation&lt;/em&gt; and &lt;em&gt;maturation&lt;/em&gt; for the Rust
project. We shipped a lot of stuff last year, and grew a lot. Now it's time to
take a step back, take stock, and prepare for the future.&lt;/p&gt;
&lt;p&gt;The work we have planned for this year falls into three major categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Governance: improving how the project is run&lt;/li&gt;
&lt;li&gt;Finish long-standing requests: closing out work we've started but never finished&lt;/li&gt;
&lt;li&gt;Polish: improving the overall quality of the language and tooling&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#governance&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;governance&quot;&gt;&lt;/a&gt;Governance&lt;/h2&gt;
&lt;p&gt;Over the last three years, the Rust project has grown a lot. Rust used to have a core team of 8 members. When we added sub-teams in 2015, we grew to 23 members. We've now grown to over 100 ‚Äî that's bigger than many companies! And of course, looking beyond the teams, the size of the Rust community as a whole has grown tremendously as well. As a result of this growth, we've found that the processes which served us well when we were a smaller project are starting to feel some strain.&lt;/p&gt;
&lt;p&gt;Many of the teams have announced plans to review and revamp their processes so as to scale better. Often this can be as simple as taking the time to write down things that previously were understood only informally ‚Äî sometimes it means establishing new structures.&lt;/p&gt;
&lt;p&gt;Because of this widespread interest in governance, we've also created a new &lt;a href=&quot;https://internals.rust-lang.org/t/governance-working-group-announcement/9637&quot;&gt;&lt;strong&gt;Governance Working Group&lt;/strong&gt;&lt;/a&gt;. This group is going to be devoted to working with each team to hone its governance structure and to help pass lessons and strategies between teams.&lt;/p&gt;
&lt;p&gt;Additionally, the RFC process has been a great boon for Rust, but as we've grown, there have been times where it didn't work so well too.
We may look at revisions to the process this year.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#long-standing-requests&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;long-standing-requests&quot;&gt;&lt;/a&gt;Long-standing requests&lt;/h2&gt;
&lt;p&gt;There are a number of exciting initiatives that have been sitting in a limbo
state ‚Äî the majority of the design is done, but there are some lingering
complications that we haven't had time to work out. This year we hope to take
a fresh look at some of these problems and try hard to resolve those
lingering problems.&lt;/p&gt;
&lt;p&gt;Examples include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Cargo team and custom registries&lt;/li&gt;
&lt;li&gt;The Language team is taking a look at async/await, specialization, const generics, and generic associated types&lt;/li&gt;
&lt;li&gt;The Libs team wants to finish custom allocators&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#polish&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;polish&quot;&gt;&lt;/a&gt;Polish&lt;/h2&gt;
&lt;p&gt;Finally, the last few years have also seen a lot of foundational work. The
compiler, for example, was massively refactored to support incremental
compilation and to be better prepared for IDEs. Now that we've got these
pieces in place, we want to do the ‚Äúpolish‚Äù work that really makes for a
great experience.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compile times and IDE support&lt;/li&gt;
&lt;li&gt;Polishing the specification of the language by improving &lt;a href=&quot;https://doc.rust-lang.org/stable/reference/&quot;&gt;the reference&lt;/a&gt; and laying out &lt;a href=&quot;https://github.com/rust-lang/unsafe-code-guidelines&quot;&gt;the unsafe code guidelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The WebAssembly WG's work this year includes polishing our wasm support, for example, debugging&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#conclusion&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This post only covered a few examples of the plans we've been making. &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md&quot;&gt;If you'd like to see the full details, take a look at the RFC itself.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here's to a great 2019 for Rust!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.34.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html" type="text/html" title="Announcing Rust 1.34.0" />
        <published>2019-04-11T00:00:00Z</published>
        <updated>2019-04-11T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.34.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.34.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate
page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.34.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.34.0-stable&quot;&gt;&lt;/a&gt;What's in 1.34.0 stable&lt;/h2&gt;
&lt;p&gt;The largest feature in this release is the introduction of &lt;em&gt;alternative&lt;/em&gt; &lt;code&gt;cargo&lt;/code&gt; registries.
The release also includes support for &lt;code&gt;?&lt;/code&gt; in documentation tests,
some improvements for &lt;code&gt;#[attribute(..)]&lt;/code&gt;s, as well as the stabilization of &lt;code&gt;TryFrom&lt;/code&gt;.
Read on for a few highlights, or see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1340-2019-04-11&quot;&gt;detailed release notes&lt;/a&gt; for additional information.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#alternative-cargo-registries&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;alternative-cargo-registries&quot;&gt;&lt;/a&gt;Alternative &lt;code&gt;cargo&lt;/code&gt; registries&lt;/h3&gt;
&lt;p&gt;Since before 1.0, Rust has had a public crate registry, &lt;a href=&quot;http://crates.io/&quot;&gt;crates.io&lt;/a&gt;.
People publish crates with &lt;code&gt;cargo publish&lt;/code&gt; and it's easy to include these crates
in the &lt;code&gt;[dependencies]&lt;/code&gt; section of your &lt;code&gt;Cargo.toml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, not everyone &lt;em&gt;wants&lt;/em&gt; to publish their crates to crates.io.
People maintaining proprietary/closed-source code cannot use crates.io,
and instead are forced to use &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;path&lt;/code&gt; dependencies.
This is usually fine for small projects, but if you have a lot of closed-source crates
within a large organization, you lose the benefit of the versioning support that crates.io has.&lt;/p&gt;
&lt;p&gt;With this release, Cargo gains support for alternate registries.
These registries coexist with crates.io, so you can write software that depends
on crates from both crates.io and your custom registry.
Crates on crates.io cannot however depend on external registries.&lt;/p&gt;
&lt;p&gt;To use an alternate registry, you must add these lines to your &lt;code&gt;.cargo/config&lt;/code&gt;.
This file can be in your home directory (&lt;code&gt;~/.cargo/config&lt;/code&gt;) or relative to the package directory.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[registries]
my-registry = { index = &amp;quot;https://my-intranet:8080/git/index&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Depending on a crate from an alternate registry is easy.
When specifying dependencies in your &lt;code&gt;Cargo.toml&lt;/code&gt;, use the &lt;code&gt;registry&lt;/code&gt; key to
let Cargo know that you wish to fetch the crate from the alternate registry:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies]
other-crate = { version = &amp;quot;1.0&amp;quot;, registry = &amp;quot;my-registry&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a crate author, if you wish to publish your crate to an alternate registry,
you first need to save the authentication token into &lt;code&gt;~/.cargo/credentials&lt;/code&gt; with the &lt;code&gt;cargo login&lt;/code&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;cargo login --registry=my-registry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can then use the &lt;code&gt;--registry&lt;/code&gt; flag to indicate which registry to use when publishing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;cargo publish --registry=my-registry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is &lt;a href=&quot;https://doc.rust-lang.org/nightly/cargo/reference/registries.html#running-a-registry&quot;&gt;documentation&lt;/a&gt; on how to run your own registry.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#-in-documentation-tests&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;-in-documentation-tests&quot;&gt;&lt;/a&gt;&lt;code&gt;?&lt;/code&gt; in documentation tests&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://rust-lang.github.io/rfcs/1937-ques-in-main.html&quot;&gt;RFC 1937&lt;/a&gt; proposed adding support for using the &lt;code&gt;?&lt;/code&gt; operator in &lt;code&gt;fn main()&lt;/code&gt;,
&lt;code&gt;#[test]&lt;/code&gt; functions, and doctests, allowing them to return &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;,
with error values causing a nonzero exit code in the case of &lt;code&gt;fn main()&lt;/code&gt;,
and a test failure in the case of the tests.&lt;/p&gt;
&lt;p&gt;Support in &lt;code&gt;fn main()&lt;/code&gt; and &lt;code&gt;#[test]&lt;/code&gt; was implemented &lt;a href=&quot;https://blog.rust-lang.org/2018/05/10/Rust-1.26.html#main-can-return-a-result&quot;&gt;many releases ago&lt;/a&gt;.
However, the support within documentation tests was limited to doctests that have an explicit &lt;code&gt;fn main()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this release, full support for &lt;code&gt;?&lt;/code&gt; in doctests has been added.
Now, you can write this in your documentation tests:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;/// ```rust
/// use std::io;
/// let mut input = String::new();
/// io::stdin().read_line(&amp;amp;mut input)?;
/// # Ok::&amp;lt;(), io::Error&amp;gt;(())
/// ```
fn my_func() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You still have to specify the error type being used at the bottom of the documentation test.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#custom-attributes-accept-arbitrary-token-streams&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;custom-attributes-accept-arbitrary-token-streams&quot;&gt;&lt;/a&gt;Custom attributes accept arbitrary token streams&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html&quot;&gt;Procedural macros&lt;/a&gt; in Rust can define custom attributes that they consume.
Until now, such attributes were restricted to being trees of paths and literals
according to a specific syntax, like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[foo(bar)]
#[foo = &amp;quot;bar&amp;quot;]
#[foo = 0]
#[foo(bar = true)]
#[foo(bar, baz(quux, foo = &amp;quot;bar&amp;quot;))]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unlike procedural macros, these helper attributes could not accept arbitrary token streams in delimiters,
so you could not write &lt;code&gt;#[range(0..10)]&lt;/code&gt; or &lt;code&gt;#[bound(T: MyTrait)]&lt;/code&gt;.
Procedural macro crates would instead use strings for specifying syntaxes like this, e.g. &lt;code&gt;#[range(&amp;quot;0..10&amp;quot;)]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;With this Rust release, custom attributes &lt;code&gt;#[attr($tokens)]&lt;/code&gt; &lt;a href=&quot;https://github.com/rust-lang/rust/pull/57367&quot;&gt;now accept&lt;/a&gt;
arbitrary token streams in &lt;code&gt;$tokens&lt;/code&gt;, bringing them on par with macros.
If you're the author of a procedural macro crate, please check if your custom attributes
have unnecessary strings in their syntax and if they can be better expressed with token streams.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#tryfrom-and-tryinto&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;tryfrom-and-tryinto&quot;&gt;&lt;/a&gt;&lt;code&gt;TryFrom&lt;/code&gt; and &lt;code&gt;TryInto&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://doc.rust-lang.org/std/convert/trait.TryFrom.html&quot;&gt;&lt;code&gt;TryFrom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/convert/trait.TryInto.html&quot;&gt;&lt;code&gt;TryInto&lt;/code&gt;&lt;/a&gt; traits were stabilized to allow fallible type conversions.&lt;/p&gt;
&lt;p&gt;For example, the &lt;a href=&quot;https://doc.rust-lang.org/std/primitive.u32.html#method.from_be_bytes&quot;&gt;&lt;code&gt;from_be_bytes&lt;/code&gt;&lt;/a&gt; and related methods on integer types take arrays,
but data is often read in via slices. Converting between slices and arrays is tedious to do manually.
With the new traits, it can be done inline with &lt;code&gt;.try_into()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let num = u32::from_be_bytes(slice.try_into()?);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For conversions that cannot fail, such as &lt;code&gt;u8&lt;/code&gt; to &lt;code&gt;u32&lt;/code&gt;, the &lt;a href=&quot;https://doc.rust-lang.org/std/convert/enum.Infallible.html&quot;&gt;&lt;code&gt;Infallible&lt;/code&gt;&lt;/a&gt; type was added.
This also permits a blanket implementation of &lt;code&gt;TryFrom&lt;/code&gt; for all existing &lt;code&gt;From&lt;/code&gt; implementations.
In the future, we hope to turn &lt;code&gt;Infallible&lt;/code&gt; into an alias for &lt;a href=&quot;https://github.com/rust-lang/rust/issues/35121&quot;&gt;the &lt;code&gt;!&lt;/code&gt; (never) type&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#fn-before_exec-deprecated-in-favor-of-unsafe-fn-pre_exec&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;fn-before_exec-deprecated-in-favor-of-unsafe-fn-pre_exec&quot;&gt;&lt;/a&gt;&lt;code&gt;fn before_exec&lt;/code&gt; deprecated in favor of &lt;code&gt;unsafe fn pre_exec&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;On Unix-like systems, the function &lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/process/trait.CommandExt.html#tymethod.before_exec&quot;&gt;&lt;code&gt;CommandExt::before_exec&lt;/code&gt;&lt;/a&gt; allows you to
schedule a closure to be run before &lt;code&gt;exec&lt;/code&gt; is invoked.&lt;/p&gt;
&lt;p&gt;The closure provided will be run in the context of the child process after a fork.
This means that resources, such as file descriptors and memory-mapped regions, may get duplicated.
In other words, you can now copy a value of a non-&lt;code&gt;Copy&lt;/code&gt; type into a different process
while retaining the original in the parent. This makes &lt;a href=&quot;https://github.com/rust-lang/rust/issues/39575#issuecomment-437658766&quot;&gt;it possible&lt;/a&gt; to cause
undefined behavior and break &lt;a href=&quot;https://github.com/rust-lang/rust/issues/39575#issuecomment-439645949&quot;&gt;libraries assuming non-duplication&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;before_exec&lt;/code&gt; should therefore have been marked as &lt;code&gt;unsafe&lt;/code&gt;.
In this release of Rust, we have deprecated &lt;code&gt;fn before_exec&lt;/code&gt; in favor of the &lt;code&gt;unsafe fn pre_exec&lt;/code&gt;.
When calling &lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/process/trait.CommandExt.html#tymethod.pre_exec&quot;&gt;&lt;code&gt;CommandExt::pre_exec&lt;/code&gt;&lt;/a&gt;, it is your responsibility to make sure that the closure
does not violate library invariants by making invalid use of these duplicates.
If you provide a library that is in a similar situation as &lt;code&gt;before_exec&lt;/code&gt;,
consider deprecating and providing an &lt;code&gt;unsafe&lt;/code&gt; alternative as well.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;In 1.34.0, the set of stable atomic integer types was expanded,
with signed and unsigned variants from 8 (&lt;a href=&quot;https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU8.html&quot;&gt;&lt;code&gt;AtomicU8&lt;/code&gt;&lt;/a&gt;) to 64 bits now available.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1280-2018-08-02&quot;&gt;Previously&lt;/a&gt;, non-zero unsigned integer types, e.g. &lt;a href=&quot;https://doc.rust-lang.org/std/num/struct.NonZeroU8.html&quot;&gt;&lt;code&gt;NonZeroU8&lt;/code&gt;&lt;/a&gt;, were stabilized.
This gave &lt;code&gt;Option&amp;lt;NonZeroU8&amp;gt;&lt;/code&gt; the same size as &lt;code&gt;u8&lt;/code&gt;.
With this Rust release, signed versions, e.g. &lt;a href=&quot;https://doc.rust-lang.org/std/num/struct.NonZeroI8.html&quot;&gt;&lt;code&gt;NonZeroI8&lt;/code&gt;&lt;/a&gt;, have been stabilized.&lt;/p&gt;
&lt;p&gt;The functions &lt;a href=&quot;https://doc.rust-lang.org/std/iter/fn.from_fn.html&quot;&gt;&lt;code&gt;iter::from_fn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/iter/fn.successors.html&quot;&gt;&lt;code&gt;iter::successors&lt;/code&gt;&lt;/a&gt; have been stabilized.
The former allows you to construct an iterator from &lt;code&gt;FnMut() -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt;.
To pop elements from a vector iteratively, you can now write &lt;code&gt;from_fn(|| vec.pop())&lt;/code&gt;.
Meanwhile, the latter creates a new iterator where each successive item
is computed based on the preceding one.&lt;/p&gt;
&lt;p&gt;Additionally, these APIs have become stable:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/any/trait.Any.html#tymethod.type_id&quot;&gt;Any::type_id&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/error/trait.Error.html#method.type_id&quot;&gt;Error::type_id&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.slice.html#method.sort_by_cached_key&quot;&gt;slice::sort_by_cached_key&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.escape_debug&quot;&gt;str::escape_debug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.escape_default&quot;&gt;str::escape_default&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.escape_unicode&quot;&gt;str::escape_unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/primitive.str.html#method.split_ascii_whitespace&quot;&gt;str::split_ascii_whitespace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Instant.html#method.checked_add&quot;&gt;Instant::checked_add&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Instant.html#method.checked_sub&quot;&gt;Instant::checked_sub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.checked_add&quot;&gt;SystemTime::checked_add&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.checked_sub&quot;&gt;SystemTime::checked_sub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1340-2019-04-11&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.33.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html" type="text/html" title="Announcing Rust 1.33.0" />
        <published>2019-02-28T00:00:00Z</published>
        <updated>2019-02-28T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.33.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.33.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes for
1.33.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.33.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.33.0-stable&quot;&gt;&lt;/a&gt;What's in 1.33.0 stable&lt;/h2&gt;
&lt;p&gt;The two largest features in this release are significant improvements to
&lt;code&gt;const fn&lt;/code&gt;s, and the stabilization of a new concept: &amp;quot;pinning.&amp;quot;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#const-fn-improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;const-fn-improvements&quot;&gt;&lt;/a&gt;&lt;code&gt;const fn&lt;/code&gt; improvements&lt;/h3&gt;
&lt;p&gt;With &lt;code&gt;const fn&lt;/code&gt;, you can &lt;a href=&quot;https://github.com/rust-lang/rust/pull/57175/&quot;&gt;now do way more
things!&lt;/a&gt; Specifically:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;irrefutable destructuring patterns (e.g. &lt;code&gt;const fn foo((x, y): (u8, u8)) { ... }&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt; bindings (e.g. &lt;code&gt;let x = 1;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;mutable &lt;code&gt;let&lt;/code&gt; bindings (e.g. &lt;code&gt;let mut x = 1;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;assignment (e.g. &lt;code&gt;x = y&lt;/code&gt;) and assignment operator (e.g. &lt;code&gt;x += y&lt;/code&gt;)
expressions, even where the assignment target is a projection (e.g. a struct
field or index operation like &lt;code&gt;x[3] = 42&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;expression statements (e.g. &lt;code&gt;3;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You're also &lt;a href=&quot;https://github.com/rust-lang/rust/pull/57067/&quot;&gt;able to call &lt;code&gt;const unsafe fn&lt;/code&gt;s inside a &lt;code&gt;const fn&lt;/code&gt;&lt;/a&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;const unsafe fn foo() -&amp;gt; i32 { 5 }
const fn bar() -&amp;gt; i32 {
    unsafe { foo() }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With these additions, many more functions in the standard library are able to
be marked as &lt;code&gt;const&lt;/code&gt;. We'll enumerate those in the library section below.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#pinning&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;pinning&quot;&gt;&lt;/a&gt;Pinning&lt;/h3&gt;
&lt;p&gt;This release introduces a new concept for Rust programs, implemented as two
types: the &lt;a href=&quot;https://doc.rust-lang.org/std/pin/struct.Pin.html&quot;&gt;&lt;code&gt;std::pin::Pin&amp;lt;P&amp;gt;&lt;/code&gt;
type&lt;/a&gt;, and the &lt;a href=&quot;https://doc.rust-lang.org/std/marker/trait.Unpin.html&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;
marker trait&lt;/a&gt;. The core
idea is elaborated on in &lt;a href=&quot;https://doc.rust-lang.org/std/pin/index.html&quot;&gt;the docs for
&lt;code&gt;std::pin&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is sometimes useful to have objects that are guaranteed to not move, in
the sense that their placement in memory does not change, and can thus be
relied upon. A prime example of such a scenario would be building
self-referential structs, since moving an object with pointers to itself will
invalidate them, which could cause undefined behavior.&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; ensures that the pointee of any pointer type &lt;code&gt;P&lt;/code&gt; has a stable location
in memory, meaning it cannot be moved elsewhere and its memory cannot be
deallocated until it gets dropped. We say that the pointee is &amp;quot;pinned&amp;quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This feature will largely be used by library authors, and so we won't talk a
lot more about the details here. Consult the docs if you're interested in
digging into the details. However, the stabilization of this API is important
to Rust users generally because it is a significant step forward towards a
highly anticipated Rust feature: &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;. We're not quite there yet,
but this stabilization brings us one step closer. You can track all of the
necessary features at &lt;a href=&quot;https://areweasyncyet.rs/&quot;&gt;areweasyncyet.rs&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#import-as-_&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;import-as-_&quot;&gt;&lt;/a&gt;Import as &lt;code&gt;_&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/56303/&quot;&gt;You can now import an item as
&lt;code&gt;_&lt;/code&gt;&lt;/a&gt;. This allows you to
import a trait's impls, and not have the name in the namespace. e.g.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use std::io::Read as _;

// Allowed as there is only one `Read` in the module.
pub trait Read {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;Here's all of the stuff that's been made &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57566&quot;&gt;The methods &lt;code&gt;overflowing_{add, sub, mul, shl, shr}&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt;
functions for all numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57105&quot;&gt;The methods &lt;code&gt;rotate_left&lt;/code&gt;, &lt;code&gt;rotate_right&lt;/code&gt;, and &lt;code&gt;wrapping_{add, sub, mul, shl, shr}&lt;/code&gt;
are now &lt;code&gt;const&lt;/code&gt; functions for all numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57105&quot;&gt;The methods &lt;code&gt;is_positive&lt;/code&gt; and &lt;code&gt;is_negative&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt; functions for
all signed numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57167&quot;&gt;The &lt;code&gt;get&lt;/code&gt; method for all &lt;code&gt;NonZero&lt;/code&gt; types is now &lt;code&gt;const&lt;/code&gt;.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57234&quot;&gt;The methods &lt;code&gt;count_ones&lt;/code&gt;, &lt;code&gt;count_zeros&lt;/code&gt;, &lt;code&gt;leading_zeros&lt;/code&gt;, &lt;code&gt;trailing_zeros&lt;/code&gt;,
&lt;code&gt;swap_bytes&lt;/code&gt;, &lt;code&gt;from_be&lt;/code&gt;, &lt;code&gt;from_le&lt;/code&gt;, &lt;code&gt;to_be&lt;/code&gt;, &lt;code&gt;to_le&lt;/code&gt; are now &lt;code&gt;const&lt;/code&gt; for all
numeric types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/57234&quot;&gt;&lt;code&gt;Ipv4Addr::new&lt;/code&gt; is now a &lt;code&gt;const&lt;/code&gt; function&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, these APIs have become stable:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.read_exact_at&quot;&gt;&lt;code&gt;unix::FileExt::read_exact_at&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.write_all_at&quot;&gt;&lt;code&gt;unix::FileExt::write_all_at&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose&quot;&gt;&lt;code&gt;Option::transpose&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose&quot;&gt;&lt;code&gt;Result::transpose&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/convert/fn.identity.html&quot;&gt;&lt;code&gt;convert::identity&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/pin/struct.Pin.html&quot;&gt;&lt;code&gt;pin::Pin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/stable/std/marker/trait.Unpin.html&quot;&gt;&lt;code&gt;marker::Unpin&lt;/code&gt;&lt;/a&gt; (mentioned above)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/marker/struct.PhantomPinned.html&quot;&gt;&lt;code&gt;marker::PhantomPinned&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.resize_with&quot;&gt;&lt;code&gt;Vec::resize_with&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.resize_with&quot;&gt;&lt;code&gt;VecDeque::resize_with&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_millis&quot;&gt;&lt;code&gt;Duration::as_millis&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_micros&quot;&gt;&lt;code&gt;Duration::as_micros&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_nanos&quot;&gt;&lt;code&gt;Duration::as_nanos&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cargo-features&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cargo-features&quot;&gt;&lt;/a&gt;Cargo features&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/cargo/pull/6484/&quot;&gt;Cargo should now rebuild a crate if a file was modified during the initial
build.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1330-2019-02-28&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cratesio&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cratesio&quot;&gt;&lt;/a&gt;Crates.io&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://users.rust-lang.org/t/a-verified-email-address-will-be-required-to-publish-to-crates-io-starting-on-2019-02-28/22425&quot;&gt;As previously announced&lt;/a&gt;, coinciding with this release, crates.io
will require that you have a verified email address to publish. Starting at
2019-03-01 00:00 UTC, if you don't have a verified email address and run &lt;code&gt;cargo publish&lt;/code&gt;, you'll get an error.&lt;/p&gt;
&lt;p&gt;This ensures we can comply with DMCA procedures. If you haven't heeded the
warnings cargo printed during the last release cycle, head on over to
&lt;a href=&quot;https://crates.io/me&quot;&gt;crates.io/me&lt;/a&gt; to set and verify your email address. This email address
will never be displayed publicly and will only be used for crates.io operations.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-133.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-133.0&quot;&gt;&lt;/a&gt;Contributors to 1.33.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.33.0. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.33.0&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Changes in the core team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/02/22/Core-team-changes.html" type="text/html" title="Changes in the core team" />
        <published>2019-02-22T00:00:00Z</published>
        <updated>2019-02-22T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/02/22/Core-team-changes.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/02/22/Core-team-changes.html">&lt;p&gt;Just a quick update: You may have noticed that, in the last month or
so, a number of &lt;a href=&quot;https://www.rust-lang.org/governance/teams/core&quot;&gt;Rust core team&lt;/a&gt; members have changed their jobs
and/or their roles in the project. Two people have decided to step
back from the core team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nick Cameron &lt;a href=&quot;https://www.ncameron.org/blog/leaving-mozilla-and-most-of-the-rust-project/&quot;&gt;left Mozilla to work at PingCap&lt;/a&gt;. Although he
won‚Äôt have time to stay active on the core team, he plans to
continue co-leading the Cargo team in his new position.&lt;/li&gt;
&lt;li&gt;Aaron Turon &lt;a href=&quot;https://internals.rust-lang.org/t/aturon-retires-from-the-core-team-but-not-from-rust/9392/3&quot;&gt;decided to step back from the core team&lt;/a&gt; so
that he could focus on engineering work and the language design
team. (He remains on the Rust team at Mozilla.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With Rust 2018 having shipped, this is a natural time of
transition. While we‚Äôll miss Nick and Aaron‚Äôs contributions to the
core team, we are very excited for them to be focusing on something
new, and we‚Äôre very happy that they are still going to stay involved
with Rust. We‚Äôre also looking into growing the core team to help with
the work ahead.&lt;/p&gt;
&lt;p&gt;Finally, two other members have changed their jobs, but plan to stay
involved in the core team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ashley Williams &lt;a href=&quot;https://twitter.com/ag_dubs/status/1088118810157219848&quot;&gt;joined Cloudflare and plans to work on Rust and WASM integration there&lt;/a&gt;.
She will be remaining on the core team.&lt;/li&gt;
&lt;li&gt;Steve Klabnik &lt;a href=&quot;https://words.steveklabnik.com/thank-u-next&quot;&gt;left Mozilla, but will remain on the core team.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That‚Äôs it!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.32.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html" type="text/html" title="Announcing Rust 1.32.0" />
        <published>2019-01-17T00:00:00Z</published>
        <updated>2019-01-17T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.32.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.32.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes for
1.32.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As a small side note, &lt;code&gt;rustup&lt;/code&gt; has seen some new releases lately! To update
&lt;code&gt;rustup&lt;/code&gt; itself, run &lt;code&gt;rustup self update&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.32.0-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.32.0-stable&quot;&gt;&lt;/a&gt;What's in 1.32.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.32.0 has a few quality of life improvements, switches the default
allocator, and makes additional functions &lt;code&gt;const&lt;/code&gt;. Read on for a few
highlights, or see the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes&lt;/a&gt; for additional
information.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#the-dbg-macro&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;the-dbg-macro&quot;&gt;&lt;/a&gt;The &lt;code&gt;dbg&lt;/code&gt; macro&lt;/h4&gt;
&lt;p&gt;First up, a quality of life improvement. Are you a &amp;quot;print debugger&amp;quot;? If you are, and
you've wanted to print out some value while working on some code, you have to do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;let x = 5;

println!(&amp;quot;{:?}&amp;quot;, x);

// or maybe even this
println!(&amp;quot;{:#?}&amp;quot;, x);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This isn't the &lt;em&gt;largest&lt;/em&gt; speed bump, but it is a lot of stuff to simply show the value of &lt;code&gt;x&lt;/code&gt;.
Additionally, there's no context here. If you have several of these &lt;code&gt;println!&lt;/code&gt;s, it can be hard
to tell which is which, unless you add your own context to each invocation, requiring even more work.&lt;/p&gt;
&lt;p&gt;In Rust 1.32.0, &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56395/&quot;&gt;we've added a new macro,
&lt;code&gt;dbg!&lt;/code&gt;&lt;/a&gt;, for this purpose:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn main() {
    let x = 5;
    
    dbg!(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run this program, you'll see:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[src/main.rs:4] x = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You get the file and line number of where this was invoked, as well as the
name and value. Additionally, &lt;code&gt;println!&lt;/code&gt; prints to the standard output, so
you really should be using &lt;code&gt;eprintln!&lt;/code&gt; to print to standard error. &lt;code&gt;dbg!&lt;/code&gt;
does the right thing and goes to &lt;code&gt;stderr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It even works in more complex circumstances. Consider this factorial example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn factorial(n: u32) -&amp;gt; u32 {
    if n &amp;lt;= 1 {
        n
    } else {
        n * factorial(n - 1)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we wanted to debug this, we might write it like this with &lt;code&gt;eprintln!&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn factorial(n: u32) -&amp;gt; u32 {
    eprintln!(&amp;quot;n: {}&amp;quot;, n);

    if n &amp;lt;= 1 {
        eprintln!(&amp;quot;n &amp;lt;= 1&amp;quot;);

        n
    } else {
        let n = n * factorial(n - 1);

        eprintln!(&amp;quot;n: {}&amp;quot;, n);

        n
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We want to log &lt;code&gt;n&lt;/code&gt; on each iteration, as well as have some kind of context
for each of the branches. We see this output for &lt;code&gt;factorial(4)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;n: 4
n: 3
n: 2
n: 1
n &amp;lt;= 1
n: 2
n: 6
n: 24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is servicable, but not particularly great. Maybe we could work on how we
print out the context to make it more clear, but now we're not debugging our code,
we're figuring out how to make our debugging code better.&lt;/p&gt;
&lt;p&gt;Consider this version using &lt;code&gt;dbg!&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;fn factorial(n: u32) -&amp;gt; u32 {
    if dbg!(n &amp;lt;= 1) {
        dbg!(1)
    } else {
        dbg!(n * factorial(n - 1))
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We simply wrap each of the various expressions we want to print with the macro. We
get this output instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;[src/main.rs:3] n &amp;lt;= 1 = false
[src/main.rs:3] n &amp;lt;= 1 = false
[src/main.rs:3] n &amp;lt;= 1 = false
[src/main.rs:3] n &amp;lt;= 1 = true
[src/main.rs:4] 1 = 1
[src/main.rs:5] n * factorial(n - 1) = 2
[src/main.rs:5] n * factorial(n - 1) = 6
[src/main.rs:5] n * factorial(n - 1) = 24
[src/main.rs:11] factorial(4) = 24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because the &lt;code&gt;dbg!&lt;/code&gt; macro returns the value of what it's debugging, instead of
&lt;code&gt;eprintln!&lt;/code&gt; which returns &lt;code&gt;()&lt;/code&gt;, we need to make &lt;em&gt;no&lt;/em&gt; changes to the structure
of our code. Additionally, we have &lt;em&gt;vastly&lt;/em&gt; more useful output.&lt;/p&gt;
&lt;p&gt;That's a lot to say about a little macro, but we hope it improves your
debugging experience! We are contining to work on support for &lt;code&gt;gdb&lt;/code&gt; and
friends as well, of course.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#jemalloc-is-removed-by-default&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;jemalloc-is-removed-by-default&quot;&gt;&lt;/a&gt;&lt;code&gt;jemalloc&lt;/code&gt; is removed by default&lt;/h4&gt;
&lt;p&gt;Long, long ago, Rust had a large, Erlang-like runtime. We chose to use
&lt;a href=&quot;http://jemalloc.net/&quot;&gt;jemalloc&lt;/a&gt; instead of the system allocator, because it often improved
performance over the default system one. Over time, we shed more and more of
this runtime, and eventually almost all of it was removed, but jemalloc
was not. We didn't have a way to choose a custom allocator, and so we
couldn't really remove it without causing a regression for people who do need
jemalloc.&lt;/p&gt;
&lt;p&gt;Also, saying that &lt;code&gt;jemalloc&lt;/code&gt; was always the default is a bit UNIX-centric,
as it was only the default on &lt;em&gt;some&lt;/em&gt; platforms. Notably, the MSVC target on
Windows has shipped the system allocator for a long time.&lt;/p&gt;
&lt;p&gt;Finally, while jemalloc &lt;em&gt;usually&lt;/em&gt; has great performance, that's not always
the case. Additionally, it adds about 300kb to every Rust binary. We've also
had a host of &lt;a href=&quot;https://github.com/rust-lang/rust/issues/36963#issuecomment-252029017&quot;&gt;other
issues&lt;/a&gt;
with jemalloc in the past. It has also felt a little strange that a systems
language does not default to the system's allocator.&lt;/p&gt;
&lt;p&gt;For all of these reasons, once &lt;a href=&quot;https://blog.rust-lang.org/2018/08/02/Rust-1.28.html#whats-in-1.28.0-stable&quot;&gt;Rust 1.28 shipped a way to choose a global
allocator&lt;/a&gt;,
we started making plans to switch the default to the system allocator, and
allow you to use &lt;code&gt;jemalloc&lt;/code&gt; via a crate. In Rust 1.32, we've finally finished
this work, and by default, you will get the system allocator for your
programs.&lt;/p&gt;
&lt;p&gt;If you'd like to continue to use jemalloc, use &lt;a href=&quot;https://crates.io/crates/jemallocator&quot;&gt;the jemallocator crate&lt;/a&gt;. In
your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;jemallocator = &amp;quot;0.1.8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in your crate root:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[global_allocator]
static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's it! If you don't need jemalloc, it's not forced upon you, and if
you do need it, it's a few lines of code away.&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#final-module-improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;final-module-improvements&quot;&gt;&lt;/a&gt;Final module improvements&lt;/h4&gt;
&lt;p&gt;In the past two releases, we announced several improvements to the module
system. We have one last tweak landing in 1.32.0 and the 2018 edition.
Nicknamed &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56759#issuecomment-450051210&quot;&gt;&amp;quot;uniform
paths&amp;quot;&lt;/a&gt;,
it permits previously invalid import path statements to be resolved exactly
the same way as non-import paths. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;enum Color { Red, Green, Blue }

use Color::*;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code did &lt;em&gt;not&lt;/em&gt; previously compile, as &lt;code&gt;use&lt;/code&gt; statements had to start with
&lt;code&gt;super&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, or &lt;code&gt;crate&lt;/code&gt;. Now that the compiler supports uniform paths,
this code will work, and do what you probably expect: import the variants of
the &lt;code&gt;Color&lt;/code&gt; enum defined above the &lt;code&gt;use&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;With this change in place, we've completed our efforts at revising the module
system. We hope you've been enjoying the simplified system so far!&lt;/p&gt;
&lt;h4&gt;&lt;a href=&quot;#macro-improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;macro-improvements&quot;&gt;&lt;/a&gt;Macro improvements&lt;/h4&gt;
&lt;p&gt;A few improvements to macros have landed in Rust 1.32.0. First, &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56072/&quot;&gt;a new
&lt;code&gt;literal&lt;/code&gt; matcher&lt;/a&gt; was added:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;macro_rules! m {
    ($lt:literal) =&amp;gt; {};
}

fn main() {
    m!(&amp;quot;some string literal&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;literal&lt;/code&gt; matches against literals of any type; string literals, numeric literals, &lt;code&gt;char&lt;/code&gt; literals.&lt;/p&gt;
&lt;p&gt;In the 2018 edition, &lt;code&gt;macro_rules&lt;/code&gt; macros can also use &lt;code&gt;?&lt;/code&gt;, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;macro_rules! bar {
    ($(a)?) =&amp;gt; {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;?&lt;/code&gt; will match zero or one repetitions of the pattern, similar to the
already-existing &lt;code&gt;*&lt;/code&gt; for &amp;quot;zero or more&amp;quot; and &lt;code&gt;+&lt;/code&gt; for &amp;quot;one or more.&amp;quot;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#library-stabilizations&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;library-stabilizations&quot;&gt;&lt;/a&gt;Library stabilizations&lt;/h3&gt;
&lt;p&gt;We talked above about the &lt;code&gt;dbg!&lt;/code&gt; macro, which is a big library addition.
Beyond that, 19 functions were made &lt;code&gt;const fn&lt;/code&gt;s, and all integral numeric
primitives now provide conversion functions to and from byte-arrays with
specified endianness. These six functions are named &lt;code&gt;to_&amp;lt;endian&amp;gt;_bytes&lt;/code&gt; and
&lt;code&gt;from_&amp;lt;endian&amp;gt;_bytes&lt;/code&gt;, where &lt;code&gt;&amp;lt;endian&amp;gt;&lt;/code&gt; is one of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ne&lt;/code&gt; - native endianness&lt;/li&gt;
&lt;li&gt;&lt;code&gt;le&lt;/code&gt; - little endian&lt;/li&gt;
&lt;li&gt;&lt;code&gt;be&lt;/code&gt; - big endian&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#cargo-features&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;cargo-features&quot;&gt;&lt;/a&gt;Cargo features&lt;/h3&gt;
&lt;p&gt;Cargo gained &lt;a href=&quot;https://github.com/rust-lang/cargo/pull/6218/&quot;&gt;&lt;code&gt;cargo c&lt;/code&gt; as an alias for &lt;code&gt;cargo check&lt;/code&gt;&lt;/a&gt;, and now &lt;a href=&quot;https://github.com/rust-lang/cargo/pull/6242/&quot;&gt;allows
usernames in registry URLs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1320-2019-01-17&quot;&gt;detailed release notes&lt;/a&gt; for more.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#contributors-to-132.0&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;contributors-to-132.0&quot;&gt;&lt;/a&gt;Contributors to 1.32.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.32.0. We couldn't have done it
without all of you. &lt;a href=&quot;https://thanks.rust-lang.org/rust/1.32.0&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Procedural Macros in Rust 2018</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html" type="text/html" title="Procedural Macros in Rust 2018" />
        <published>2018-12-21T00:00:00Z</published>
        <updated>2018-12-21T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html">&lt;p&gt;Perhaps my favorite feature in the Rust 2018 edition is &lt;a href=&quot;https://doc.rust-lang.org/reference/procedural-macros.html&quot;&gt;procedural macros&lt;/a&gt;.
Procedural macros have had a long and storied history in Rust (and will continue
to have a storied future!), and now is perhaps one of the best times to get
involved with them because the 2018 edition has so dramatically improved the
experience both defining and using them.&lt;/p&gt;
&lt;p&gt;Here I'd like to explore what procedural macros are, what they're capable of,
notable new features, and some fun use cases of procedural macros. I might even
convince you that this is Rust 2018's best feature as well!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#what-is-a-procedural-macro&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-is-a-procedural-macro&quot;&gt;&lt;/a&gt;What is a procedural macro?&lt;/h3&gt;
&lt;p&gt;First defined over two years ago in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1566-proc-macros.md&quot;&gt;RFC 1566&lt;/a&gt;, procedural macros are, in
layman's terms, a function that takes a piece of syntax at compile time and
produces a new bit of syntax. Procedural macros in Rust 2018 come in one of
three flavors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;#[derive]&lt;/code&gt; mode macros&lt;/strong&gt; have actually been stable since &lt;a href=&quot;https://blog.rust-lang.org/2017/02/02/Rust-1.15.html&quot;&gt;Rust 1.15&lt;/a&gt;
and bring all the goodness and ease of use of &lt;code&gt;#[derive(Debug)]&lt;/code&gt; to
user-defined traits as well, such as &lt;a href=&quot;https://serde.rs&quot;&gt;Serde&lt;/a&gt;'s &lt;code&gt;#[derive(Deserialize)]&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Function-like macros&lt;/strong&gt; are newly stable to the 2018 edition and allow
defining macros like &lt;code&gt;env!(&amp;quot;FOO&amp;quot;)&lt;/code&gt; or &lt;code&gt;format_args!(&amp;quot;...&amp;quot;)&lt;/code&gt; in a
crates.io-based library. You can think of these as sort of &amp;quot;&lt;code&gt;macro_rules!&lt;/code&gt;
macros&amp;quot; on steroids.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Attribute macros&lt;/strong&gt;, my favorite, are also new in the 2018 edition
and allow you to provide lightweight annotations on Rust functions which
perform syntactical transformations over the code at compile time.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each of these flavors of macros can be defined in a crate with &lt;code&gt;proc-macro = true&lt;/code&gt; &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/manifest.html&quot;&gt;specified in its manifest&lt;/a&gt;. When used, a procedural macro is
loaded by the Rust compiler and executed as the invocation is expanded. This
means that Cargo is in control of versioning for procedural macros and you can
use them with all same ease of use you'd expect from other Cargo dependencies!&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#defining-a-procedural-macro&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;defining-a-procedural-macro&quot;&gt;&lt;/a&gt;Defining a procedural macro&lt;/h3&gt;
&lt;p&gt;Each of the three types of procedural macros are &lt;a href=&quot;https://doc.rust-lang.org/stable/reference/procedural-macros.html&quot;&gt;defined in a slightly different
fashion&lt;/a&gt;, and here we'll single out attribute macros. First, we'll flag
&lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[lib]
proc-macro = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then in &lt;code&gt;src/lib.rs&lt;/code&gt; we can write our macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn hello(attr: TokenStream, item: TokenStream) -&amp;gt; TokenStream {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then write some unit tests in &lt;code&gt;tests/smoke.rs&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[my_crate::hello]
fn wrapped_function() {}

#[test]
fn works() {
    wrapped_function();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;... and that's it! When we execute &lt;code&gt;cargo test&lt;/code&gt; Cargo will compile our
procedural macro. Afterwards it will compile our unit test which loads the macro
at compile time, executing the &lt;code&gt;hello&lt;/code&gt; function and compiling the resulting
syntax.&lt;/p&gt;
&lt;p&gt;Right off the bat we can see a few important properties of procedural macros:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The input/output is this fancy &lt;code&gt;TokenStream&lt;/code&gt; type we'll talk about more in a
bit&lt;/li&gt;
&lt;li&gt;We're &lt;em&gt;executing arbitrary code&lt;/em&gt; at compile time, which means we can do just
about anything!&lt;/li&gt;
&lt;li&gt;Procedural macros are incorporated with the module system, meaning they can
be imported just like any other name.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before we take a look at implementing a procedural macro, let's first dive into
some of these points.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#macros-and-the-module-system&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;macros-and-the-module-system&quot;&gt;&lt;/a&gt;Macros and the module system&lt;/h3&gt;
&lt;p&gt;First stabilized in &lt;a href=&quot;https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html&quot;&gt;Rust 1.30&lt;/a&gt; (noticing a trend with 1.15?) macros are now
integrated with the module system in Rust. This mainly means that you no longer
need the clunky &lt;code&gt;#[macro_use]&lt;/code&gt; attribute when importing macros! Instead of this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[macro_use]
extern crate log;

fn main() {
    debug!(&amp;quot;hello, &amp;quot;);
    info!(&amp;quot;world!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;you can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use log::info;

fn main() {
    log::debug!(&amp;quot;hello, &amp;quot;);
    info!(&amp;quot;world!&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Integration with the module system solves one of the most confusing parts about
macros historically. They're now imported and namespaced just as you would any
other item in Rust!&lt;/p&gt;
&lt;p&gt;The benefits are not only limited to bang-style &lt;code&gt;macro_rules&lt;/code&gt; macros, as you can
now transform code that looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[macro_use]
extern crate serde_derive;

#[derive(Deserialize)]
struct Foo {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;into&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use serde::Deserialize;

#[derive(Deserialize)]
struct Foo {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and you don't even need to explicitly depend on &lt;code&gt;serde_derive&lt;/code&gt; in &lt;code&gt;Cargo.toml&lt;/code&gt;!
All you need is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-toml&quot;&gt;[dependencies]
serde = { version = '1.0.82', features = ['derive'] }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href=&quot;#whats-inside-a-tokenstream?&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-inside-a-tokenstream?&quot;&gt;&lt;/a&gt;What's inside a &lt;code&gt;TokenStream&lt;/code&gt;?&lt;/h3&gt;
&lt;p&gt;This mysterious &lt;code&gt;TokenStream&lt;/code&gt; type comes from the &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/&quot;&gt;compiler-provided
&lt;code&gt;proc_macro&lt;/code&gt; crate&lt;/a&gt;. When it was first added all you could do with a
&lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; was call convert it to or from a string using &lt;code&gt;to_string()&lt;/code&gt; or &lt;code&gt;parse()&lt;/code&gt;.
As of Rust 2018, you can act on the tokens in a &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; directly.&lt;/p&gt;
&lt;p&gt;A &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is effectively &amp;quot;just&amp;quot; an iterator over &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/enum.TokenTree.html&quot;&gt;&lt;code&gt;TokenTree&lt;/code&gt;&lt;/a&gt;. All
syntax in Rust falls into one of these four categories, the four variants of
&lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/enum.TokenTree.html&quot;&gt;&lt;code&gt;TokenTree&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ident&lt;/code&gt; is any identifier like &lt;code&gt;foo&lt;/code&gt; or &lt;code&gt;bar&lt;/code&gt;. This also contains keywords
such as &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;super&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Literal&lt;/code&gt; include things like &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt;, and &lt;code&gt;'b'&lt;/code&gt;. All literals are one
token and represent constant values in a program.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Punct&lt;/code&gt; represents some form of punctuation that's not a delimiter. For
example &lt;code&gt;.&lt;/code&gt; is a &lt;code&gt;Punct&lt;/code&gt; token in the field access of &lt;code&gt;foo.bar&lt;/code&gt;.
Multi-character punctuation like &lt;code&gt;=&amp;gt;&lt;/code&gt; is represented as two &lt;code&gt;Punct&lt;/code&gt; tokens,
one for &lt;code&gt;=&lt;/code&gt; and one for &lt;code&gt;&amp;gt;&lt;/code&gt;, and the &lt;code&gt;Spacing&lt;/code&gt; enum says that the &lt;code&gt;=&lt;/code&gt; is
adjacent to the &lt;code&gt;&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Group&lt;/code&gt; is where the term &amp;quot;tree&amp;quot; is most relevant, as &lt;code&gt;Group&lt;/code&gt; represents a
delimited sub-token-stream. For example &lt;code&gt;(a, b)&lt;/code&gt; is a &lt;code&gt;Group&lt;/code&gt; with parentheses
as delimiters, and the internal token stream is &lt;code&gt;a, b&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While this is conceptually simple, this may sound like there's not much we can
do with this! It's unclear, for example, how we might parse a function from a
&lt;code&gt;TokenStream&lt;/code&gt;. The minimality of &lt;code&gt;TokenTree&lt;/code&gt; is crucial, however, for
stabilization. It would be infeasible to stabilize the Rust AST because that
means we could never change it. (imagine if we couldn't have added the &lt;code&gt;?&lt;/code&gt;
operator!)&lt;/p&gt;
&lt;p&gt;By using &lt;code&gt;TokenStream&lt;/code&gt; to communicate with procedural macros, the compiler is
able to add new language syntax while also being able to compile
and work with older procedural macros. Let's see now, though, how we can
actually get useful information out of a &lt;code&gt;TokenStream&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#parsing-a-tokenstream&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;parsing-a-tokenstream&quot;&gt;&lt;/a&gt;Parsing a &lt;code&gt;TokenStream&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;If &lt;code&gt;TokenStream&lt;/code&gt; is just a simple iterator, then we've got a long way to go from
that to an actual parsed function. Although the code is already lexed for us
we still need to write a whole Rust parser! Thankfully though the community has
been hard at work to make sure writing procedural macros in Rust is as smooth as
can be, so you need look no further than the &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt; crate&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With the &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt; crate we can parse any Rust AST as a one-liner:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[proc_macro_attribute]
pub fn hello(attr: TokenStream, item: TokenStream) -&amp;gt; TokenStream {
    let input = syn::parse_macro_input!(item as syn::ItemFn);
    let name = &amp;amp;input.ident;
    let abi = &amp;amp;input.abi;
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt; crate not only comes with the ability to parse built-in syntax
but you can also easily write a recursive descent parser for your own syntax.
The &lt;a href=&quot;https://docs.rs/syn/0.15/syn/parse/index.html&quot;&gt;&lt;code&gt;syn::parse&lt;/code&gt; module&lt;/a&gt; has more information about this capability.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#producing-a-tokenstream&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;producing-a-tokenstream&quot;&gt;&lt;/a&gt;Producing a &lt;code&gt;TokenStream&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Not only do we take a &lt;code&gt;TokenStream&lt;/code&gt; as input with a procedural macro, but we
also need to produce a &lt;code&gt;TokenStream&lt;/code&gt; as output. This output is typically
required to be valid Rust syntax, but like the input it's just list of tokens
that we need to build somehow.&lt;/p&gt;
&lt;p&gt;Technically the only way to create a &lt;code&gt;TokenStream&lt;/code&gt; is via its &lt;code&gt;FromIterator&lt;/code&gt;
implementation, which means we'd have to create each token one-by-one and
collect it into a &lt;code&gt;TokenStream&lt;/code&gt;. This is quite tedious, though, so let's take a
look at &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;'s sibling crate: &lt;a href=&quot;https://docs.rs/quote/0.6/quote/&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.rs/quote/0.6/quote/&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt; crate is a quasi-quoting implementation for Rust which primarily
provides a convenient macro for us to use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;use quote::quote;

#[proc_macro_attribute]
pub fn hello(attr: TokenStream, item: TokenStream) -&amp;gt; TokenStream {
    let input = syn::parse_macro_input!(item as syn::ItemFn);
    let name = &amp;amp;input.ident;

    // Our input function is always equivalent to returning 42, right?
    let result = quote! {
        fn #name() -&amp;gt; u32 { 42 }
    };
    result.into()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href=&quot;https://docs.rs/quote/0.6/quote/macro.quote.html&quot;&gt;&lt;code&gt;quote!&lt;/code&gt; macro&lt;/a&gt; allows you to write mostly-Rust syntax and interpolate
variables quickly from the environment with &lt;code&gt;#foo&lt;/code&gt;. This removes much of the
tedium of creating a &lt;code&gt;TokenStream&lt;/code&gt; token-by-token and allows quickly cobbling
together various pieces of syntax into one return value.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#tokens-and-span&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;tokens-and-span&quot;&gt;&lt;/a&gt;Tokens and &lt;code&gt;Span&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Perhaps the greatest feature of procedural macros in Rust 2018 is the ability to
customize and use &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; information on each token, giving us the ability for
amazing syntactical error messages from procedural macros:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: expected `fn`
 --&amp;gt; src/main.rs:3:14
  |
3 | my_annotate!(not_fn foo() {});
  |              ^^^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;as well as completely custom error messages:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: imported methods must have at least one argument
  --&amp;gt; invalid-imports.rs:12:5
   |
12 |     fn f1();
   |     ^^^^^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; can be thought of as a pointer back into an original source file,
typically saying something like &amp;quot;the &lt;code&gt;Ident&lt;/code&gt; token&lt;code&gt; foo&lt;/code&gt; came from file
&lt;code&gt;bar.rs&lt;/code&gt;, line 4, column 5, and was 3 bytes long&amp;quot;. This information is
primarily used by the compiler's diagnostics with warnings and error messages.&lt;/p&gt;
&lt;p&gt;In Rust 2018 each &lt;a href=&quot;https://doc.rust-lang.org/stable/proc_macro/enum.TokenTree.html&quot;&gt;&lt;code&gt;TokenTree&lt;/code&gt;&lt;/a&gt; has a &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; associated with it. This means that
if you preserve the &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.Span.html&quot;&gt;&lt;code&gt;Span&lt;/code&gt;&lt;/a&gt; of all input tokens into the output then even
though you're producing brand new syntax the compiler's error messages are still
accurate!&lt;/p&gt;
&lt;p&gt;For example, a small macro like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#[proc_macro]
pub fn make_pub(item: TokenStream) -&amp;gt; TokenStream {
    let result = quote! {
        pub #item
    };
    result.into()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;when invoked as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;my_macro::make_pub! {
    static X: u32 = &amp;quot;foo&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;is invalid because we're returning a string from a function that should return a
&lt;code&gt;u32&lt;/code&gt;, and the compiler will helpfully diagnose the problem as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0308]: mismatched types
 --&amp;gt; src/main.rs:1:37
  |
1 | my_macro::make_pub!(static X: u32 = &amp;quot;foo&amp;quot;);
  |                                     ^^^^^ expected u32, found reference
  |
  = note: expected type `u32`
             found type `&amp;amp;'static str`

error: aborting due to previous error

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can see here that although we're generating brand new syntax, the
compiler can preserve span information to continue to provide targeted
diagnostics about code that we've written.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#procedural-macros-in-the-wild&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;procedural-macros-in-the-wild&quot;&gt;&lt;/a&gt;Procedural Macros in the Wild&lt;/h3&gt;
&lt;p&gt;Ok up to this point we've got a pretty good idea about what procedural macros
can do and the various capabilities they have in the 2018 edition. As such a
long-awaited feature, the ecosystem is already making use of these new
capabilities! If you're interested, some projects to keep your eyes on are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.rs/quote/0.6/quote/&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.rs/proc-macro2/0.4/proc_macro2/&quot;&gt;&lt;code&gt;proc-macro2&lt;/code&gt;&lt;/a&gt; are your go-to libraries for
writing procedural macros. They make it easy to define custom parsers, parse
existing syntax, create new syntax, work with older versions of Rust, and much
more!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://serde.rs&quot;&gt;Serde&lt;/a&gt; and its derive macros for &lt;code&gt;Serialize&lt;/code&gt; and &lt;code&gt;Deserialize&lt;/code&gt; are likely the
most used macros in the ecosystem. They sport an &lt;a href=&quot;https://serde.rs/attributes.html&quot;&gt;impressive amount of
configuration&lt;/a&gt; and are a great example of how small annotations
can be so powerful.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/rustwasm/wasm-bindgen&quot;&gt;&lt;code&gt;wasm-bindgen&lt;/code&gt; project&lt;/a&gt; uses attribute macros to easily define
interfaces in Rust and import interfaces from JS. The &lt;code&gt;#[wasm_bindgen]&lt;/code&gt;
lightweight annotation makes it easy to understand what's coming in and out,
as well as removing lots of conversion boilerplate.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://gitlab.gnome.org/federico/gnome-class&quot;&gt;&lt;code&gt;gobject_gen!&lt;/code&gt; macro&lt;/a&gt; is an experimental IDL for the GNOME
project to define GObject objects safely in Rust, eschewing manually writing
all the glue necessary to talk to C and interface with other GObject
instances in Rust.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;a href=&quot;https://rocket.rs/&quot;&gt;Rocket framework&lt;/a&gt; has recently switched over to procedural
macros, and showcases some of nightly-only features of procedural macros like
custom diagnostics, custom span creation, and more. Expect to see these
features stabilize in 2019!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That's just a &lt;em&gt;taste&lt;/em&gt; of the power of procedural macros and some example usage
throughout the ecosystem today. We're only 6 weeks out from the original release
of procedural macros on stable, so we've surely only scratched the surface as
well! I'm really excited to see where we can take Rust with procedural macros by
empowering all kinds of lightweight additions and extensions to the language!&lt;/p&gt;
</content>

        <author>
            <name>Alex Crichton</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.31.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2018/12/20/Rust-1.31.1.html" type="text/html" title="Announcing Rust 1.31.1" />
        <published>2018-12-20T00:00:00Z</published>
        <updated>2018-12-20T00:00:00Z</updated>
        <id>https://blog.rust-lang.org/2018/12/20/Rust-1.31.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2018/12/20/Rust-1.31.1.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.31.1. Rust is a
systems programming language focused on safety, speed, and concurrency.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.31.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don't have it already, you can &lt;a href=&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href=&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1311-2018-12-20&quot;&gt;detailed release notes for
1.31.1&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#whats-in-1.31.1-stable&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;whats-in-1.31.1-stable&quot;&gt;&lt;/a&gt;What's in 1.31.1 stable&lt;/h2&gt;
&lt;p&gt;This patch release fixes a build failure on &lt;code&gt;powerpc-unknown-netbsd&lt;/code&gt; by
way of &lt;a href=&quot;https://github.com/rust-lang/rust/pull/56562&quot;&gt;an update to the &lt;code&gt;libc&lt;/code&gt;
crate&lt;/a&gt; used by the compiler.&lt;/p&gt;
&lt;p&gt;Additionally, the Rust Language Server was updated to fix two critical bugs.
First, &lt;a href=&quot;https://github.com/rust-lang/rls/pull/1170&quot;&gt;hovering over the type with documentation above single-line
attributes led to 100% CPU
usage:&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;/// Some documentation
#[derive(Debug)] // Multiple, single-line
#[allow(missing_docs)] // attributes
pub struct MyStruct { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rust-lang/rls/pull/1171&quot;&gt;Go to definition was fixed for std types&lt;/a&gt;:
Before, using the RLS on &lt;code&gt;HashMap&lt;/code&gt;, for example, tried to open this file&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/libstd/collections/hash/map.rs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and now RLS goes to the correct location (for Rust 1.31, note the extra &lt;code&gt;src&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/collections/hash/map.rs
&lt;/code&gt;&lt;/pre&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
</feed>